\newcommand{\algorithmautorefname}{Algorithm}
\newcommand{\algeqref}[1]{\hyperref[#1]{Eq.~\ref*{#1}}}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\MakeRobust{\Call}

\restylefloat{algorithm}

\section{Star Identification Methods}\label{sec:starIdentificationMethods}

\subsection{Generic Identification Method}\label{subsec:genericIdentificationMethod}
\begin{figure}
    \centering{
    \input{include/generic-identification}
    \caption{
    Flowchart depicting a general star identification process.
    Given an image $I$, this processes returns a map $a$ pairing some subset of the input $b$ to a subset of
    the catalog $r$.
    } \label{figure:genericIdentificationMethodFlowchart}
    }
\end{figure}

Each identification method is presented with an image $I$ of all the stars in the image reference frame.
The goal of each method is to find some 1:1 mapping between the \textit{subset} of the image stars $b$ and a subset
of the catalog stars $r$.
This mapping will be denoted as $a$.
Complete identification of the all stars in each image is not the focus.

Every algorithm starts with some combination $c$ from all possible $k$ combinations of $|I|$ stars $C_k^{|I|}$, where
$k = $ the size of the image subset that specific identification method uses.
The subset of stars from the image is selected using the current combination $c$.
For an identification method that uses $k=2$ stars to determine the mapping in an image of $|I|=4$ stars, the
combinations of $I$ are:
\begin{equation}
    C_2^4 \text{ combinations of } I = \{(I_0, I_1), (I_0, I_2), \ldots, (I_3, I_4)\}
\end{equation}

Using certain features of the image star subset, a \textit{set} of catalog star sets $R$ is obtained.
$R$ is a list of catalog star candidates as to which the image star subset should map to.
Referencing the same $k=2$ identification method as before, an image subset $b = (I_0, I_1)$ may yield the candidates
in~\autoref{eq:catalogCandidateExample}:
\begin{equation}
    \label{eq:catalogCandidateExample}
    R = \{ (r_{104}, r_{899}), (r_{7622}, r_{7771}), \ldots) \}
\end{equation}

Through some filter process, a single set $r$ from the catalog star candidates is then selected.
If all of these steps are successful, then a map $a$ between the catalog subset and image subset is determined and
returned.
Otherwise, a new combination $c$ is selected and the entire process is repeated.
This process is detailed in~\autoref{figure:genericIdentificationMethodFlowchart}.
In the event no map can be determined, an error is raised and an empty map is returned (not depicted in the flowchart).

% Leaving this out for now. The flowchart should explain the process better.
%\begin{algorithm} \setstretch{1.0}[H]
%    \caption{Generic Star Identification Method} \label{algorithm:genericStarIdentification}
%    \begin{algorithmic}[1]
%        \Procedure{Identify}{}
%        \State $I \gets $ all stars from image
%        \For{$c \in r_k^{|I|}$}
%        \State $b \gets \{I(c_1), I(c_2), I(c_3), \dots, I(r_k)\}$
%        \State $R \gets $ catalog star sets, each set of size $=k$
%        \State $r \gets $ a single set from $R$ that matches $b$
%        \State $a \gets $ a map between $b$ and $r$
%        \\
%        \If{the steps above are successful}
%        \State \textbf{return} $a$
%        \EndIf
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

% Citation: https://digitalcommons.usu.edu/cgi/viewcontent.cgi?article=2723&context=etd AND Gottlieb.
\subsection{Gottlieb's Angle Method}\label{subsec:gottlieb'sAngleMethod}
In 1978, Gottlieb developed the Polygon Angular Matching method~\cite{Angle,AnalysisUncompensated}.
Starting with an image, two stars $b = (b_i, b_j)$ are selected arbitrarily.
The corresponding angular separation between each of these stars from a defined observer is computed:
$\theta (b_i, b_j) = \theta^{ij}$.
All possible pairs $(r_m, r_n)$ in the catalog are then selected such that~\autoref{eq:angleRequirement} holds.
The set that holds these pairs is denoted as $R$.

\begin{equation}
    \label{eq:angleRequirement}
    \left\lvert  \theta(r_m, r_n) - \theta^{ij} \right\rvert < 3 \sigma
\end{equation}
$\sigma$ represents the deviation of the uncertainty between the star sensor measurements and the points defined in the
catalog.
Assuming the noise follows a Gaussian distribution, it follows that 99.7\% of all true pairs will be within this range.

If there exists more than one catalog pair after this reduction, then this process is repeated for
different combinations of the complete image set until a unique pair is found or all combinations are exhausted.
To determine a mapping, a \textit{direct match test} (DMT) is performed.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Angle Identification Method} \label{algorithm:angleIdentification}
    \begin{algorithmic}[1]
        \Procedure{Identify}{}
        \State $I \gets \text{all stars} \text{ from image}$
        \For{$i \gets 1 \text{\textbf{ to }} |I|$} \Comment Iterate through $C^{|I|}_2$
        \For{$j \gets i + 1 \text{\textbf{ to }} |I| - 1$}
        \State $b \gets (b_i, b_j)$
        \State $R \gets $ catalog pairs that meet~\algeqref{eq:angleRequirement} with $b$
        \\
        \If{$\lvert R \rvert = 1$}
        \State $r \gets $ singular pair inside $R$
        \State $a \gets $ \Call{DMT}{$b, r, I$}
        \State \textbf{return} $a$
        \EndIf
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{subequations}
    Needleman specifies this DMT method, which extracts an attitude after running this candidate finding
    step~\cite{Tappe,DMT}.
    Given an image star pair $(b_i, b_j)$ and a catalog star pair $(r_m, r_n)$, a map is proposed:
    \begin{equation}
        a_1 = (b_i \rightarrow r_m, b_j \rightarrow r_n)
    \end{equation}

    Wahba's problem (extracting an attitude given vector observations in two coordinate systems) is then solved using
    the TRIAD method.
    This gives a rotation $q_1$ between the image and catalog frames.
    This process is repeated for the other possible map to obtain a second rotation $q_2$:
    \begin{equation}
        a_2 = (b_i \rightarrow r_n, b_j \rightarrow r_m)
    \end{equation}
\end{subequations}

The most likely attitude is determined by predicting which entries in the catalog represent stars in the image
(the "find positive overlay", or \Call{FPO}{} method) using $q_1$ and $q_2$.
The mapping with the most correctly predicted stars is then returned as the resulting attitude.
The general form for this function (accepting star sets of arbitrary size) is described
in~\autoref{algorithm:angleHelper}.

To determine the number of correctly predicted stars, another procedure is specified in~\autoref{algorithm:angleHelper}.
This filters out stars in set $P$ that do not overlay with some star in $I'$, the image set rotated by some rotation
$q$.
An additional term $\sigma_o$ is defined, which defines how selective this filter.
$\sigma_o$ can also be thought of as an assumption of the noise associated with the rotation $q$.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Functions for Angle Method}\label{algorithm:angleHelper}
    \begin{algorithmic}[1]
        \Function{FPO}{$P$, $I$, $q$}
        \State $I' \gets$ stars in $I$ rotated by $q$
        \State $\bar{P} \gets $ \{$p \in P \ | \ \exists \ i \ (i \in I' \land \theta (i, p) < 3\sigma_o)$\}
        \State \textbf{return} $\bar{P}$ \Comment stars in $P$ that \textit{overlay} with $I'$
        \EndFunction
        \\
        \Function{DMT}{$b, r, I$}
        \State $A \gets $ all possible permutations between $b$ and $r$
        \State $P \gets $ all stars in catalog near $r$
        \\
        \For {$a \in A$}
        \State $q \gets $ \Call{TRIAD}{$a$}
        \State $M_a \gets $ \Call{FPO}{$P, I, q$}
        \EndFor
        \State \textbf{return} map $a$ associated with \Call{Max}{$M$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The time complexity of this algorithm $T_{angle}$ is depicted below.
This is dependent on the combinations of pairs in the given image (the first term) and the \Call{DMT}{} procedure.
Note that the time to query our catalog is defined as constant here.
\begin{equation}\label{eq:complexityAngle}
    T_{angle} = O\left( C^{|I|}_2 \right) + \Theta \left( |I| \times |P| \right)
\end{equation}

\subsection{Liebe's Dot Angle Method}\label{subsec:liebe'sDotAngleMethod}
In 1995, Liebe developed the Liebe Star ID method~\cite{Survey,AnalysisUncompensated}.
Starting with an image $I$, a central star $b_c$ is selected arbitrarily.
The two closest stars in the image to the central star are selected next, denoted as $b_i$ and $b_j$.
Three features are then computed: the angular separation between the first closest star and the central star $\theta
(b_i, b_c) = \theta^{ic}$, the angular separation between the second closest star and the central star $\theta (b_j,
b_c) = \theta^{jc}$, and the angle between the two closest stars with the central star as the vertex $\phi$.

The additional constraint that $\theta^{ic} < \theta^{jc}$ is imposed before proceeding.
If this is not true, then stars $b_i$ and $b_j$ are swapped and this process is repeated.
By adding this restriction to the catalog search, a star mapping procedure (e.g.\ Needleman's direct match test) is no
longer required.
This does increase the storage required for the catalog, but in favor of efficiency.

\begin{subequations}
    \label{eq:dotAngleRequirement}

    All possible \textit{trios} $R$ in the catalog are then selected such that all
    of~\autoref{eq:dotAngleRequirement} hold.
    In the equations below $r_o$ corresponds to a central star in the catalog, $r_m$ corresponds to the closest star
    in the catalog to the catalog central star, and $r_n$ corresponds to the next closest star:
    \begin{align}
        \left\lvert \theta(r_m, r_o) - \theta^{ic}\right\rvert &< 3 \sigma_{\theta_{ic}} \\
        \left\lvert\theta(r_n, r_o) - \theta^{jc}\right\rvert &< 3 \sigma_{\theta_{jc}} \\
        \left\lvert\phi(r_m, r_n, r_o) - \phi\right\rvert &< 3 \sigma_{\phi} \\
        \theta(r_m, r_o) &< \theta(r_n, r_o)
    \end{align}
\end{subequations}

$\sigma_{\theta}$ and $\sigma_{\phi}$ represent the deviation of measurement-catalog uncertainty of angular separations
and dot angular separations respectively.
\textit{Note that the $R$ in this procedure is distinct from the $R$ in the previous Angle method.}

The star trios in the catalog star candidates represent potential catalog maps for the image star trio $(b_i, b_j,
b_c)$.
Liebe's original method states that this process should be repeated for all stars in the image, meaning that all
stars will be the central star at one point
By the end, each star in the image will have accrued a set of possible catalog matches $Y$.
The complete $I \rightarrow R$ map is found by picking the most frequent catalog star appearing in each $Y$
set~\cite{DotAngle,AnalysisUncompensated}.

To more closely follow the generic star identification flow, we modified the Dot Angle method to not store $Y$,
require that only one central star choice is needed to acquire a total match, and removed the "closest stars"
constraints for $r_n$ and $r_m$.
If a confident match is not found by the first central star, then the search process will be repeated until such a
match is found.
This entire method is described in~\autoref{algorithm:dotAngleIdentification}.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Dot Angle Identification Method} \label{algorithm:dotAngleIdentification}
    \begin{algorithmic}[1]
        \Procedure{Identify}{}
        \State $I \gets \text{all stars } \text{ from image}$
        \For{$i \gets 1 \text{\textbf{ to }} |I|$}  \Comment Iterate through $C^{|I|}_3$
        \For{$j \gets i + 1 \text{\textbf{ to }} |I| - 1$}
        \For{$c \gets j + 1 \text{\textbf{ to }} |I| - 2$}
        \State $b \gets (b_i, b_j)$
        \State $R \gets $ catalog trios that meet~\algeqref{eq:dotAngleRequirement} with $b$
        \\
        \If{$\lvert R \rvert = 1$}
        \State $(r_m, r_n, r_o) \gets $ singular pair inside $R$
        \State $a \gets (b_i \rightarrow r_m, b_j \rightarrow r_n, b_c \rightarrow r_o)$
        \State \textbf{return} $a$
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The time complexity of this algorithm $T_{dot}$ is depicted below.
This is dependent on the combinations of trios in the given image.
Again, note that the time to query our catalog is defined as constant here.
\begin{equation}\label{eq:dotComplexity}
    T_{dot} = O \left( C^{|I|}_3 \right)
\end{equation}

\subsection{Cole and Crassidus's Spherical Triangle Method}\label{subsec:coleAndCrassidus'sSphericalTriangleMethod}
\begin{subequations}
    \label{eq:triangleRequirement}
    In 2004, Cole and Crassidus developed the Spherical Triangle method~\cite{Spherical}.
    Starting with an image $I$, three stars $b = (b_i, b_j, b_k)$ are selected arbitrarily.
    Treating the trio as a spherical triangle, the spherical area and moment are computed.
    This is denoted as $a^{ijk}$ and $\imath^{ijk}$ respectively.
    Similar to Gottlieb's method, star \textit{trios} $R$ are selected from the catalog such that the all
    of~\autoref{eq:triangleRequirement} hold:
    \begin{align}
        \left\lvert a(r_m, r_n, r_o) - a^{ijk} \right\rvert &< 3 \sigma_a \\
        \left\lvert  \imath(r_m, r_n, r_o) - \imath^{ijk} \right\rvert &< 3\sigma_{\imath}
    \end{align}
\end{subequations}
$\sigma_a$ and $\sigma_{\imath}$ represent the deviation of measurement-catalog uncertainty of spherical areas and
moments respectively.

If there exists more than one catalog trio, then a \textit{pivot} is performed.
The pivoting process is repeated until a unique match in the original catalog star candidate set $R_{t=1}$ is found,
or all possible pivots are performed.
The entire catalog search procedure is repeated until a unique catalog trio is found, or all trios in the image have
been used.
This procedure is described in~\autoref{algorithm:triangleIdentification}.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Triangle Method Identification} \label{algorithm:triangleIdentification}
    \begin{algorithmic}[1]
        \Procedure{Identify}{}
        \State $I \gets \text{all stars} \text{ from image}$
        \For{$i \gets 1 \text{\textbf{ to }} |I|$}  \Comment Iterate through $C^{|I|}_3$
        \For{$j \gets i + 1 \text{\textbf{ to }} |I| - 1$}
        \For{$k \gets j + 1\text{\textbf{ to }} |I| - 2$}
        \State $b \gets (b_i, b_j, b_k)$
        \State $R \gets$ \Call{Pivot}{$b_i, b_j, b_k, \emptyset$}
        \\
        \If{$R \neq \emptyset$}Note
        \State $r \gets $ singular pair inside $R$
        \State $a \gets $ \Call{DMT}{$b, r, I$}
        \State \textbf{return} $a$
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The pivot procedure starts by setting $R$ to $R_{t=1}$, beginning the pivot with the trio set that was just queried
for.
A second set of trios $R_{t=2}$ is retrieved for a different image star set $\bar{b} = (b_i, b_j, \hat{b_k})$.
For the second star set, the first two stars are held constant and the third star is swapped with another in the image.
All star trios in the initial search that do not match a trio in the second search by \textit{two stars} (a partial
match) are removed from the initial search candidate star set.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Functions for Triangle Identification} \label{algorithm:triangleHelper}
    \begin{algorithmic}[1]
        \Function{PartialMatch}{$R_1, R_t$}
        \ForAll {$v \in R_t$}
        \LineComment $v$ and $u$ share two stars
        \If {$\exists \ u \ | \ (u \in R_1 \land |u \cap v| > 2)$}
        \State $\bar{R_1} \gets \bar{R_1} \cup \{v\}$
        \EndIf
        \EndFor
        \State \textbf{return} $\bar{R_1}$
        \EndFunction
        \\
        \Function{Pivot}{$b_i, b_j, b_k, R_1$}
        \State $b \gets (b_j, b_j, b_k)$
        \State $R_t \gets $ catalog trios that meet~\algeqref{eq:triangleRequirement} with $b$
        \State $R_1 \gets $ \Call{PartialMatch}{$R_t, R_1$}
        \\
        \If{$|R_1| = 1$}
        \State \textbf{return} $R_1$
        \ElsIf{$|R_1| = 0$}
        \State \textbf{return} $\emptyset$
        \Else
        \State $\hat{b_k} \gets \text{an unused star in this pivot}$
        \State \textbf{return} \Call{Pivot}{$b_i, b_j, \hat{b_k}, R_1$}
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{subequations}
    Cole and Crassidus do not specify identification steps, so Needleman's DMT process is used to complete the star
    identification process.
    Given an image star trio and a catalog star trio, an map is proposed:
    \begin{equation}
        a_1 = (s_i \rightarrow r_m, b_j \rightarrow r_n, b_k \rightarrow r_o)
    \end{equation}

    \label{eq:trianglePossibleMaps}
    The TRIAD method only uses two vector observations from each frame, meaning that the $b_k \rightarrow r_k$ map is
    disregarded as the first rotation $q_1$ is computed.
    This process is repeated for all 5 other possible mappings to get $q_2, q_3, \dots, q_6$.
    \begin{align}
        a_2 &= (s_i \rightarrow r_m, b_j \rightarrow r_o, b_k \rightarrow r_n) \\
        a_3 &= (s_i \rightarrow r_n, b_j \rightarrow r_m, b_k \rightarrow r_o) \\
        a_4 &= (s_i \rightarrow r_n, b_j \rightarrow r_o, b_k \rightarrow r_m) \\
        a_5 &= (s_i \rightarrow r_o, b_j \rightarrow r_m, b_k \rightarrow r_n) \\
        a_6 &= (s_i \rightarrow r_o, b_j \rightarrow r_n, b_k \rightarrow r_m)
    \end{align}
\end{subequations}

For all six attitudes, the map yielding the most correctly predicted stars is returned as the resulting attitude.

\begin{subequations}
    The time complexity of this algorithm $T_{sphere}$ is depicted below.
    This is dependent on the combinations of trios in the image, and the complexity of the \Call{Pivot}{} procedure.
    \begin{align}\label{eq:sphereComplexity}
        T_{sphere} &= O \left( C^{|I|}_3 \right) \times T_{pivot} \\
        T_{pivot} &= \Theta\left(n_1 n_t |I| + |I| \right) + \Theta \left( |I| \times |P| \right)
    \end{align}
    where $n_1$ and $n_t$ is the size of $R_1$ and $R_t$ at time $t$ respectively.
\end{subequations}

The $n_1 n_t$ terms come from the \Call{PartialMatch}{} procedure, which may be performed for all stars in the image.
The extra additional of the $|I|$ term comes from the process of finding an unused star in a given pivot.
At best, this requires the cost of determining which stars find $\hat{b_k}$ for a pivot at $t=1$.
This requires looping through the entire list.
The last term comes from the \Call{DMT}{} call.

\subsection{Cole and Crassidus's Planar Triangle Method}\label{subsec:coleAndCrassidus'sPlanarTriangleMethod}
In 2006, Cole and Crassidus developed the Planar Triangle method~\cite{Planar}.
This is identical to their Spherical Triangle method, with the exception that each image trio is represented as a
planar triangle instead of a spherical one.

Computing the spherical moment requires the use of recursion, which could be costly in slower hardware to obtain more
precision.
The Planar Triangle method avoids this by computing the planar area and moment instead, which do not require this
recursive step.

% Mortari introduced the use of \textit{search-less} catalog access using the $k$-vector approach, but this will not be
% discussed in this paper.
\subsection{Mortari's Pyramid Star Identification Method}\label{subsec:mortari'sPyramidStarIdentificationMethod}
In 2004, Mortari developed the Pyramid method~\cite{Pyramid}.
Starting with an image $I$, three stars $b = (b_i, b_j, b_k)$ are selected in a manner to avoid the persistence of
false stars.
This is specified in lines 19 to 23 in~\autoref{algorithm:pyramidIdentification}.
The corresponding angular separation between each distinct combination of the three is computed, yielding $\theta
(b_i, b_j) = \theta^{ij}, \theta(b_i, b_k) = \theta^{ik}, \theta(b_j, b_k) = \theta^{jk}$.

All possible \textit{pair sets} $R^{mn}, R^{mo}, R^{no}$ are selected from the catalog such
that~\autoref{eq:angleRequirement} holds for each respective angular separation.
The common stars between each of these pairs inside candidate star sets are then determined, yielding $T^m, T^n, $ and
$T^o$.
If there exists a sole element inside each common star set, then a secondary verification involving guessing a nearby
star is performed.
If this verification step passes, a map is then returned.
This entire process is described in~\autoref{algorithm:pyramidIdentification}.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Pyramid Identification Method} \label{algorithm:pyramidIdentification}
    \begin{algorithmic}[1]
        \Function {FindCatalogStars} {$b, I$}
        \State $R^{mn} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with ($b_i, b_j$)
        \State $R^{mo} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with ($b_i, b_k$)
        \State $R^{no} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with ($b_j, b_k$)
        \\
        \State $T^m \gets $ \Call{Common}{$R^{mn}, R^{mo}$}
        \State $T^n \gets $ \Call{Common}{$R^{mn}, R^{no}$}
        \State $T^o \gets $ \Call{Common}{$R^{mo}, R^{no}$}
        \\
        \If{$|T^m| = 1 \land |T^j| = 1 \land |T^k| = 1$}
        \State $r \gets $ singular stars in $T_i, T_j, T_k$
        \If{\Call{VerifyP}{$r, b, I$} is \textbf{true}}
        \State \textbf{return} $r$
        \EndIf
        \EndIf
        \State \textbf{return} $\emptyset$
        \EndFunction
        \\
        \Procedure{Identify}{}
        \State $I \gets \text{all stars } s \text{ from image}$
        \\
        \LineComment Iterate through $C^{|I|}_3$ using \textit{smart scan technique}
        \For{$dj \gets 1 \text{\textbf{ to }} |I| - 2$}
        \For{$dk \gets 1 \text{\textbf{ to }} |I| - 1 - dj$}
        \For{$k \gets i \text{\textbf{ to }} |I| - dj - dk$}
        \State $j \gets i + dj$
        \State $k \gets j + dk$
        \\
        \State $b \gets (b_i, b_j, b_k)$
        \State $r \gets$ \Call{FindCatalogStars}{$b, I$}
        \If{$r \neq \emptyset$}
        \State $a \gets (b_i \rightarrow r_i, b_j \rightarrow r_j, b_k \rightarrow r_k)$
        \State \textbf{return} $a$
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The common stars $T^a$ in two sets of star \textit{pairs} $R^{ab}$ and $R^{ac}$, is found by "flattening" the list of
pairs and taking the union of the two.
\begin{equation}
    \label{eq:commonStarsPyramid}
    T^a = \{ r | r \in R \in R^{ab} \} \cap \{ r | r \in R \in R^{ac} \}
\end{equation}

If $R^{ab} = \{ (1, 2), (2, 3) \}$ and $R^{ac} = \{ (2, 5), (7, 3) \}$, then the common stars for $a$ is
$T^a = \{2, 3\}$.

%The function \Call{Common}{$R^{ab}, R^{ac}, E$} in~\autoref{algorithm:pyramidHelpers} also specifies an $E$
%parameter, which acts as a "exclusion" set.
%Once a common star is found $T^i$, it follows that the next common star to be found $T^j$ should not include this
% previously found star.

The second verification step is denoted as \Call{VerifyP}{$r, b, I$} in~\autoref{algorithm:pyramidHelpers}.
This function starts by selecting a nearby star to image star set $b_e$.
The angular separation between each star in the current image star set to this new star is computed, producing
$\theta^{ie}, \theta^{je}, \theta^{ke}$.
Each of these angular separations can be thought of as the edges to the pyramid head $b_e$, with the base of the pyramid
being the original triangle $b_i, b_j, b_k$.

Again, three sets of catalog pairs $R^{mu}, R^{nu}, R^{ou}$ are selected such that~\autoref{eq:angleRequirement} holds
for each respective $\theta$.
If the common star between all $R$ sets exists near the given $r$ set (within some angle $f$), then the test passes.
Otherwise, the test fails.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Functions for Pyramid Identification} \label{algorithm:pyramidHelpers}
    \begin{algorithmic}[1]
        \Function{Common}{$R^{ab}, R^{ac}$}
        \State \textbf{return} all stars that meet~\algeqref{eq:commonStarsPyramid} with $R^{ab}, R^{ac}$
        \EndFunction
        \\
        \Function{VerifyP}{$r, b, I$}
        \State $b_e \gets $ star in image $I$ not in $b$
        \State $R^{mu} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with $(b_i, b_e)$
        \State $R^{nu} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with $(b_j, b_e)$
        \State $R^{ou} \gets$ catalog pairs that meet~\algeqref{eq:angleRequirement} with $(b_k, b_e)$
        \\
        \State $T^u \gets $ \Call{Common}{$R^{mu},$ \Call{Common}{$R^{nu}, R^{ou}$}}
        \If{$|T^u| = 1$}
        \State $r_u \gets $ singular star in $T^u$
        \If{$\forall \ \hat{r} \ | \ (\hat{r} \in r \land \theta(\hat{r}, r_u) < f)$}
        \State \textbf{return true} \Comment Require that $r_u$ is near $r$
        \EndIf
        \EndIf
        \State \textbf{return false}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{subequations}
    \label{eq:pyramidComplexity}
    The time complexity of this algorithm $T_{pyramid}$ is depicted below.
    This is dependent on the combinations of trios in the given image and the size of each catalog candidate set used
    in the \Call{Common}{} procedure.
    \begin{align}
        T_{pyramid} &= O\left( C^{|I|}_3 \right) \times T_{common} \\
        T_{common} &= \Theta\left( n_1 n_2 + n_2 n_3 + n_1 n_3 + n_4 n_5 n_6 \right)
    \end{align}
\end{subequations}
where $n_1, n_2, n_3$ represent the size of $R^{mn}, R^{mo}, R^{no}$ respectively for a given \Call{FindCatalogStars}{}
call and $n_4, n_5, n_6$ represent the size of $R^{mu}, R^{nu}, R^{ou}$ respectively for a given \Call{VerifyP}{}
call.

\subsection{Toloei's Composite Pyramid Method}\label{subsec:toloei'sCompositePyramidMethod}
In 2014, Toloei developed the Novel Stars ID method, which retains all of the key aspects of Motari's
Pyramid method but uses the features from Cole and Crassidus's Planar Triangle method for the query and reference steps
instead of angles~\cite{Composite}.
Starting with an image $I$, three stars $b = (b_i, b_j, b_k)$ are selected in the same false star persistence avoidance
manner as the Pyramid method.
Treating the trio as a planar triangle, the planar area and moment are computed.
This is denoted as $a^{ijk}$ and $\imath^{ijk}$ respectively.
Similar to the Planar Triangle method, star \textit{trios} $R$ are selected from the catalog such
that~\autoref{eq:triangleRequirement} hold.

Unlike the triangle methods, no pivot is performed.
This searching process is repeated until a unique candidate set is found.
Toloei does not specify an attitude determination method, and a map cannot be determined using common
stars like the Pyramid method.
To bridge this gap, Needleman's DMT process is used in the same manner as the Triangle methods.
With a map determined, the secondary verification step involving guessing a nearby star is performed.
If this verification step passes, then the mapping is returned.
This entire process is described in~\autoref{algorithm:compositePyramidIdentification}.

\begin{algorithm}
    \setstretch{1.0}
    \caption{Composite Pyramid Identification Method} \label{algorithm:compositePyramidIdentification}
    \begin{algorithmic}[1]
        \Function {FindCatalogStars} {$b, I$}
        \State $R \gets $ catalog trios that meet~\algeqref{eq:triangleRequirement} with $b$
        \\
        \If{$\lvert R \rvert = 1$}
        \State $r \gets $ singular trio inside $R$
        \State $a \gets $ \Call{DMT}{$b, r, I$}
        \If{\Call{VerifyC}{$a, I$} is \textbf{true}}
        \State \textbf{return} $a$
        \EndIf
        \EndIf
        \State \textbf{return } $\emptyset$
        \EndFunction
        \\
        \Procedure{Identify}{}
        \State $I \gets \text{all stars } s \text{ from image}$
        \\
        \LineComment Iterate through $C^{|I|}_3$ using \textit{smart scan technique}
        \For{$dj \gets 1 \text{\textbf{ to }} |I| - 2$}
        \For{$dk \gets 1 \text{\textbf{ to }} |I| - 1 - dj$}
        \For{$k \gets i \text{\textbf{ to }} |I| - dj - dk$}
        \State $j \gets i + dj$
        \State $k \gets j + dk$
        \\
        \State $b \gets (b_i, b_j, b_k)$
        \State $a \gets$ \Call{FindCatalogStars}{$b, I$}
        \If{$a \neq \emptyset$}
        \State \textbf{return} $a$
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The second verification step is denoted as \Call{VerifyC}{$b, r, a, I$}
in~\autoref{algorithm:compositePyramidHelpers}.
$b$ and $r$ are given to this method in an arbitrary order.
The actual map is determined by $a$ from the \Call{DMT}{} call, yielding $b^{\star}$ and $r^{\star}$ whose stars $i, j,
k$ pair with each other.
\begin{equation}
    (b^\star_i \rightarrow r^\star_i, b^\star_j \rightarrow r^\star_j, b^\star_k \rightarrow r^\star_k )
\end{equation}

Like the Pyramid verification function, this verification starts by selecting a nearby star to $b$ in the image $b_e$.
The planar area and moment are computed for the trios $(b_e, b_i, b_j)$, $(b_e, b_i, b_k)$, and $(b_e, b_j, b_k)$.
These are all of the possible triangles formed with the inclusion of the verification star and two of the original
trio $b$.
In the original Pyramid method, the angular separations could be thought of as pyramid edges.
Here, each triangle can be thought of as a face of the pyramid.

The catalog trio sets $R^{umn}, R^{umo}$, and $R^{uno}$ are then retrieved.
The same function \Call{Common}{$R^{ab}, R^{ac}$} from the Pyramid method is used to determine what $b_e$ is.
\begin{algorithm}
    \setstretch{1.0}
    \caption{Functions for Composite Pyramid Identification} \label{algorithm:compositePyramidHelpers}
    \begin{algorithmic}[1]
        \Function{VerifyC}{$b, r, a, I$}
        \State $b_e \gets $ star in image $I$ not in $b$
        \State $b^{\star} \gets $ stars in $b$ mapped using $a$
        \State $r^{\star} \gets $ stars in $r$ mapped using $a$

        \State $R^{umn} \gets $ catalog trios that meet~\algeqref{eq:triangleRequirement} with $(b_e, b^{\star}_i,
        b^{\star}_j)$
        \State $R^{umo} \gets $ catalog trios that meet~\algeqref{eq:triangleRequirement} with $(b_e, b^{\star}_i,
        b^{\star}_k)$
        \State $R^{uno} \gets $ catalog trios that meet~\algeqref{eq:triangleRequirement} with $(b_e, b^{\star}_j,
        b^{\star}_k)$
        \State $T^u \gets $ \Call{Common}{$R^{umn},$ \Call{Common}{$R^{umo}, R^{uno}$}}
        \\
        \If{$|T^u| = 1$}
        \State $r_u \gets $ singular star in $T^u$
        \If{$\forall \ \hat{r} \ | \ (\hat{r} \in r \land \theta(\hat{r}, r_u) < f)$}
        \State \textbf{return true} \Comment Require that $r_u$ is near $r$
        \EndIf
        \EndIf
        \State \textbf{return false}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The time complexity of this algorithm $T_{composite}$ is depicted below.
This is dependent on the combinations of trios in the image, and the \Call{Common}{} and \Call{DMT}{} calls.
\begin{equation}
    T_{composite} = O\left( C^{|I|}_3 \right) + \Theta\left( |I| \times |P| + n_1 n_2 n_3 \right)
\end{equation}
where $n_1, n_2, n_3$ represent $R^{umn}, R^{umo}, R^{uno}$ from the \Call{VerifyC}{} call.

\begin{table*}[ht]
    \centering{
    \caption{
    Overview table of the different identification methods.
    Each method's image features, reduction process, identification process is displayed.
    } \label{tab:identificationMethodOverview}
    \input{include/summary-table}
    }
\end{table*}