\newcommand{\algorithmautorefname}{Algorithm}

\newcommand{\algeqref}[1]{\hyperref[#1]{Eq.~\ref*{#1}}}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\algrenewcommand\algorithmicindent{0.35cm}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\MakeRobust{\Call}

\newfloat{algorithm}{t}{lop}
\restylefloat{algorithm}

\section{Constellation Query Processing Strategies}\label{sec:starIdentificationMethods}
Six different approaches to constellation query processing are described in this section.
The majority of the literature does not include pseudocode, rather they specify
descriptions of specific processes used by each strategy.
Each algorithm is composed of these processes, structured to follow a general
processing workflow.
%When the description did not specify a step in this flow, a simple or existing approach from another strategy was used.
%Several deviations to the algorithms from the original literature were introduced from newer literature to evaluate
%the effectiveness of these changes.

\subsection{Unified Identification Strategy Framework}\label{subsec:unifiedIdentification}
Each identification strategy is presented with information about the camera hardware, an image $I$ of size $n$
containing all the stars in the image reference, as well as a set of known stars $K$ residing in some database.
All stars in $I$ exist in the body frame $\iFrame$, and all stars in $K$ exist in the inertial frame $\kFrame$.
The goal of each constellation query is to find some 1:1 mapping between a subset of the image stars $b$ and a subset
of the database stars $r$.
This function is denoted as $h$ with domain $b$, range $r$, and codomain $K$.
Identification of all stars in each image is not the focus.

\begin{subequations}
    Every algorithm starts with some combination from all possible $d$ combinations of $n$ stars $C(n, d)$, where
    $d$ is the size of the image subset that specific identification strategy uses.
    $b$ is selected using one of these combinations.
    For an identification strategy that uses $d\seq2$ stars to determine the mapping in an image of $n\seq 4$ stars,
    the combinations of $I$ are:
    \begin{align}
        C(4, 2) \text{ of } I &= \set{\set{\vv{I_1}, \vv{I_2}}, \set{\vv{I_1}, \vv{I_3}}, \ldots,
        \set{\vv{I_3}, \vv{I_4}}} \\
        C(4, 2) \text{ of } I &= \set{ b_1, b_2, \ldots, b_6 }
    \end{align}
\end{subequations}

\begin{subequations}
    There exists a set $K^d$, composed of $d$ sized sets of all possible combinations (or permutations) of stars
    from $K$.
    Using certain features of the image star subset, the entire $K^d$ set is filtered to a set of database star
    candidates $R$.
    This is known as the $R$ retrieval step.
    Referencing the same $d\seq 2$ identification strategy as before, an image subset $b \seq \set{\vv{I_1},
    \vv{I_2}}$ may yield the candidates in~\autoref{eq:catalogCandidateExample}:
    \begin{align}
        \label{eq:catalogCandidateExample}
        R &= \set{ \set{\vv{K_{104}}, \vv{K_{899}}}, \set{\vv{K_{7622}}, \vv{K_{7771}}}, \ldots) } \\
        R &= \set{ r_1, r_2, \ldots }
    \end{align}
\end{subequations}

Through some filter process or restriction criteria for $R$ itself, a single set $r$ from the database star candidates
is eventually selected.
This may require going through multiple database candidate sets and repeating the $R$ retrieval step.
This is known as the database candidate $r$ selection step.
For a process with the $R$ restriction criterion of $|R| \seq 1$, the following sequence
of events may occurring before finding a single $r$ set.
%\begin{description}[noitemsep]
%    \item[$t = 1:$] $\text{ query with } b^{(1)}, \text{ get } R^{(1)} = \{\vv{r_{11}}, \vv{r_{12}}, \ldots\}.$
%    \item[$t = 2:$] $\abs{ R^{(1)} } \neq 1, \text{ criterion not met. }$
%    \item[$t = 3:$] $\text{ choose new image subset } b^{(2)}.$
%    \item[$t = 4:$] $\text{ query with } b^{(2)}, \text{ get } R^{(2)} = \{\vv{r_{21}}\}.$
%    \item[$t = 5:$] $\abs{ R^{(2)} } = 1, \text{ criterion met. }$
%    \item[$t = 6:$] $\text{ return } r, r \in R^{(2)} (\text{sole element in } R^{(2)} ).$
%\end{description}
\begin{align*}
    &t = 1, \text{ retrieve with } b^{(1)}, \text{ get } R^{(1)} = \{\vv{r_{11}}, \vv{r_{12}}, \ldots\}. \\
    &t = 2, \ \abs{ R^{(1)} } \neq 1, \text{ criterion not met. } \\
    &t = 3, \text{ choose new image subset } b^{(2)}. \\
    &t = 4, \text{ retrieve with } b^{(2)}, \text{ get } R^{(2)} = \{\vv{r_{21}}\}. \\
    &t = 5, \ \abs{ R^{(2)} } = 1, \text{ criterion met. } \\
    &t = 6, \text{ return } r, r \in R^{(2)} (\text{sole element in } R^{(2)} ).
\end{align*}

\newcommand{\smapsto}{\! \mapsto \!}
From here, a injection $h \mid b \smapsto r$ is determined that maps each star found in the image
star subset to a single star in the database candidate set.
For brevity, it is assumed that all functions in this paper have domain $b$ and codomain $K$.
If we are not confident in $h$ at this point, another image star subset is chosen and the process is repeated.
If we are confident in $h$, then $b$ and $h$ are returned.
This process is detailed in~\autoref{figure:unifiedIdentificationFlowchart}.
In the event all possible $b$ sets have been selected, $h$ with mapping $b \smapsto \emptyset$ is returned instead.

% Leaving this out for now. The flowchart should explain the process better.
%\begin{algorithm}[ht] \setstretch{1.0}[H]
%    \caption{Generic Star Identification Method} \label{algorithm:genericStarIdentification}
%    \begin{algorithmic}[1]
%        \Procedure{Identify}{}
%        \State $I \gets $ all stars from image
%        \For{$c \in r_k^{|I|}$}
%        \State $b \gets \{I(c_1), I(c_2), I(c_3), \dots, I(r_k)\}$
%        \State $R \gets $ catalog star sets, each set of size $=k$
%        \State $r \gets $ a single set from $R$ that matches $b$
%        \State $a \gets $ a map between $b$ and $r$
%        \\
%        \If{the steps above are successful}
%        \State \textbf{return} $a$
%        \EndIf
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

% Citation: https://digitalcommons.usu.edu/cgi/viewcontent.cgi?article=2723&context=etd AND Gottlieb.
\subsection{Angle Strategy (ANG)}\label{subsec:angleMethod}
\newcommand{\invalidBijection}{\If{$\forall \ \vv{b^\star}, \ \vv{b^\star} \in b \land h\left(\vv{b^\star}\right)
\neq \emptyset$}}
\begin{algorithm}
    \caption{Angle Identification Strategy} \label{algorithm:angleIdentification}
    \begin{algorithmic}[1]
        \Function{FPO}{$P$, $I$, $A$}
        \State $I' \gets$ stars in $I$ rotated by $A$
        \State $\bar{P} \gets $ \{$p \in P \ | \ \exists \ i \ (i \in I' \land \theta (i, p) < 3\sigma_o)$\}
        \State \textbf{return} $\bar{P}$ \Comment Stars in $P$ that \textit{overlay} with $I'$.
        \EndFunction
%        \\
        \Function{DMT}{$b, r, I$}
        \State $H \gets $ $b \times r$ \Comment All possible pairings of $b$ and $r$.
        \State $P \gets $ all stars in database near $r$, $M \gets \emptyset$
        \For {$h \in H$}
        \State $A \gets $ \Call{TRIAD}{$h, b, r$}, $M_h \gets $ \Call{FPO}{$P, I, A$}
        \EndFor
        \If{$\forall \ M_h \left( M_h \in M \land \abs{M_h} = \abs{b} \right)$}
        \State \textbf{return} $h \mid b \mapsto \emptyset $ \Comment Not confident in result.
        \Else
        \State \textbf{return} $h \in H$ associated with largest set in $M$
        \EndIf
        \EndFunction
%        \\
        \Function{Identify}{$I, K^2$}
        \For{$i \gets 1 \text{\textbf{ to }} n$} \Comment Iterate through $C(n, 2)$. \label{algline:angleI}
        \For{$j \gets i + 1 \text{\textbf{ to }} n - 1$} \label{algline:angleJ}
        \State $b \gets \left(\vv{b_i}, \vv{b_j}\right)$, $R \gets \{ r \mid r \in K^2 \land P_\theta(r, b) \}$
%        \State $R \gets $ catalog pairs that meet~\algeqref{eq:angleRequirement} with $b$
        \If{$\lvert R \rvert = 1$}
        \State $h \gets $ \Call{DMT}{$b, R_1, I$} % TODO: Maybe change this notation...
        \invalidBijection
        \State \textbf{return} $b, h$
        \EndIf
        \EndIf
        \EndFor
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The \textit{Angle} strategy is composed of a naive $b$ image subset decision, angular features of pairs first described
by Gottlieb's Polygon Angular Matching strategy, and a direct-match test for identification.

Given a set of stars from the image $I$, $d \seq 2$ stars are selected to obtain the $b$ set.
The selection order is governed by lines~\ref{algline:angleI} and~\ref{algline:angleJ}
in~\autoref{algorithm:angleIdentification}.
This fixes the star $\vv{b_1}$ in $b$ for $n$ image star subset selections, while constantly changing
$\vv{b_2}$ for every new $b$ choice.
An example sequence of pairs is depicted below for $n \seq 3$ stars.
\begin{equation}
    C(3, 2) \text{ of } I = \left(\set{\vv{I_1}, \vv{I_2}}, \set{\vv{I_1},\vv{I_3}}, \set{\vv{I_2},\vv{I_1}},
    \ldots \right)
\end{equation}

The $R$ retrieval step searches the $K^2$ set for pairs such that the angular separations of the database pairs
are close to the separations of the image star subset~\cite{bratt:analysisStarIdentification}.
For the image star subset, the origin of the separation calculation $\theta(b)$ is the focal point of the lens
itself.
For a database star candidate set, the origin of this calculation $\theta(r)$ is the center of the Earth.
To obtain $R$, the predicate $P_\theta(r, b)$ is used to filter the $K^2$ database:
\begin{equation}\label{eq:angleRequirement}
    P_{\theta}(r, b) : \left\lvert \theta(r) - \theta(b)\right\rvert < 3 \sigma_\theta
\end{equation}
where $\sigma_{\theta}$ represents the deviation of the uncertainty between the $\theta$ computation with star
sensor measurements and the same $\theta$ computation with stars defined in the database.
Assuming the noise follows a Gaussian distribution, it follows that 99.7\% of all true pairs will be within this range
~\cite{coleAndCrassidis:sphericalTriangleMethod}.

Once the database candidates are obtained, the $\abs{R} \seq 1$ criterion is imposed, repeating this process until only
one candidate exists in $R$.
This sole element $\vv{R_1}$ is then selected to be $r$.

\begin{subequations}
    To determine the most likely injection $h$, we follow Tappe's implementation of the strategy and perform a
    \textit{direct match test} (DMT)~\cite{tappe:starTrackerDevelopment,needelman:stellarAttitudeAcquisition}.
    Given an image star pair $b$ and a database star pair $r$ for, the following is proposed.
    \begin{equation}
        h_1 \mid h_1(b_1) = r_1, \ h_1(b_2) = r_2
    \end{equation}
    Wahba's problem is then solved using the TRIAD method to obtain a rotation $A_1$ between the image and database
    frames.
    This process is repeated for the other possible permutation to obtain a second rotation $A_2$:
    \begin{equation}
        h_2 \mid h_2(b_1) = r_2, \ h_2(b_2) = r_1
    \end{equation}
\end{subequations}
The most likely attitude is determined by the \Call{FPO}{} method, which returns how many stars from $I$ align with
$K$ given rotation $A_1$ or $A_2$.
The injection with the most stars is then returned.
If all injections return sets of size $d \seq 2$, then we are not confident in any of our choices and
return the function $h \mid \vv{b} \smapsto \emptyset$.

%The \Call{FPO}{} method determines the number of stars from $I$ in the body frame $\iFrame$ align with $C$ in the
%inertial frame $\kFrame$.
%More stars are selected from the catalog that are near the original subset $r$, denoted as $P$.
%The \Call{FPO}{} method then filters out stars in set $P$ that do not overlay with some star in $I'$, the image set
%rotated by some rotation $q$.
%An additional term $\sigma_o$ is defined, which defines how selective this filter.
%$\sigma_o$ can also be thought of as an assumption of the noise associated with the rotation $q$.

Accessing the database is the most expensive operation for all of the identification strategies.
Consequently, the running time of this algorithm $T_{angle}$ can be described in terms of the number of queries and
the number of elements that exist in $K^2$.
There exist $2n^2$ database accesses at worst, requiring two database accesses ($R$ retrieval step and \Call{DMT}{}
calls) for each combination of pairs in $I$.
The $\log (m_2)$ term describes the number of comparisons until $r$ sets are found and are able to be returned.
Given a B+ tree indexed relation with $\abs{K^2} \seq m_2$ elements, no more than $\bigO \left( \log(m_2) \right)$
comparisons are required~\cite{patel:advanceTreeStructures}.
%\begin{equation}\label{eq:complexityAnglePart1}
%    T_{angle} = \bigO\left(C(n, 2) \cdot n \cdot \log(m_{angle}) \right)
%\end{equation}
%We expand the combination term to get:
%\begin{equation}
%    C(n, 2) = \frac{n(n - 1)}{2} = \frac{n^2}{4} - \frac{n}{4}
%\end{equation}
%~\autoref{eq:complexityAnglePart1} then simplifies to~\autoref{eq:complexityAngle}:
\begin{equation}\label{eq:complexityAngle}
    T_{angle} = \bigO\left( n^2 \cdot \log(m_2) \right)
\end{equation}

%All methods associated with the Angle method are written in~\autoref{algorithm:angleIdentification}.

\subsection{Interior Angle Strategy (INT)}\label{subsec:interiorAngleMethod}
\begin{algorithm}
    \caption{Interior Angle Identification Strategy} \label{algorithm:interiorAngleIdentification}
    \begin{algorithmic}[1]
        \Function{Identify}{$I, \bar{K^3}$}
        \For{$c \gets 1 \text{\textbf{ to }} n$}  \Comment Iterate through all of $I$.
        \State $\theta_I \gets \{\theta(\vv{b_c}, \vv{b_i}) \mid \vv{b_i} \in I\}$ \Comment $\theta$
        (all stars, $\vv{b_c}$).
        \State $\vv{b_{c1}} \gets \vv{b_i}$ associated with smallest $\theta$ in $\theta_I$
        \State $\vv{b_{c2}} \gets \vv{b_i}$ associated with 2nd smallest $\theta$ in $\theta_I$
        \State $b \gets \left(\vv{b_c}, \vv{b_{c1}}, \vv{b_{c2}}\right)$, $R \gets \set{ r \mid r \in \bar{K^3} \land
        P_{\theta, \phi}(r, b) }$
        \If{$\lvert R \rvert = 1$}
%        \State \textbf{return} $b, r, h: (\vv{b_c}, \vv{r_c}), (\vv{b_{c1}, \vv{r_{c1}}}), (\vv{b_{c2}, \vv{r_{c2}}})$
        \State \textbf{return} $b, h \mid h(r_c) = b_{c}, \ h(r_{c1}) = b_{c1},$
        \State \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  $h(r_{c2}) = b_{c2}$
        \EndIf
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The \textit{Interior Angle} strategy is composed of Liebe's feature set (two interstar angles, an interior angle),
Liebe's $b$ image subset decision, and a permutation store for identification.

Given a set of stars from the image $I$, a central star $\vv{b_c}$ is selected.
A new central star selection does not involve generating permutations like the Angle strategy, rather it involves
iterating through $I$ in a sequential manner.
The two closest stars in the image to the central star are selected next, denoted as $\vv{b_{c1}}$ and $\vv{b_{c2}}$
~\cite{liebe:starTrackersAttitudeDetermination}.

The $R$ retrieval step searches the $\bar{K^3}$ set for trios such that the features of the database trios are
close to the same features of the image subset~\cite{bratt:analysisStarIdentification}.
Unlike the Angle strategy's $K^d$ set, $\bar{K^d}$ is defined to be all \textit{permutations} of size $d$ rather than
combinations.
These features are defined as the angular separation between the first closest star and the central star
($\theta\left(\vv{b_{c1}}, \vv{b_c}\right)$ vs. $ \theta\left(\vv{r_{c1}}, \vv{r_c}\right)$), the
angular separation between the second closest star and the central star, ($\theta\left(\vv{b_{c2}},
\vv{b_c}\right) $ vs. $\theta\left(\vv{r_{c2}}, \vv{r_c}\right)$),
and the angular separation between the two closest stars with the central star as the origin instead of the Earth or 
focal point ($\phi(b) $ vs. $ \phi(r)$).
To obtain $R$, the predicate $P_{\theta, \phi}(r, b)$ is used to filter $\bar{K^3}$:

\begin{equation}
    \begin{aligned}
        P_{\theta, \phi} (r, b): \left\lvert \theta(\vv{r_{c1}}, \vv{r_c}) - \theta(\vv{b_{c1}}, \vv{b_c})\right\rvert
        &< 3 \sigma_{\theta} \ \land \\ \left\lvert \theta(\vv{r_{c2}}, \vv{r_c}) - \theta(\vv{b_{c2}}, 
        \vv{b_c})\right\rvert &< 3 \sigma_{\theta} \ \land \\ \left\lvert \phi(r) - \phi(b)\right\rvert &< 3 
        \sigma_\phi \ \land \\\theta(\vv{r_{c1}}, \vv{r_c}) &< \theta(\vv{r_{c2}}, \vv{r_c})
    \end{aligned}
\end{equation}
where $\sigma_{\theta}$ and $\sigma_{\phi}$ represent the deviation of the uncertainty between the $\theta$ and $\phi$
computations with the star sensor measurements and the same $\theta$ and $\phi$ computations with stars defined in the
database.

%The original literature states that this should be repeated for all $b$ sets.
%Given that complete identification of $I$ is not the goal, this method has been adjusted to query with one $b$ at a
%time.
After finding some $R$ that meets the same $R$ criterion as the Angle strategy, the injection:
\begin{equation}
    h \mid h(b_1) = r_1, \ h(b_2) = r_2, \ h(b_3) = r_3
\end{equation}
is constructed and returned.
RezaToloei's implementation imposes the last term in predicate $P_{\theta, \phi}(r, b)$ at $R$ retrieval
time~\cite{toloei:compositeIdentification}, borrowing from Anderson (according to Spratling) by searching all
permutations instead of combinations to remove the need for a star mapping
procedure~\cite{anderson:autonomousStarSensing}.
Storing permutations does increase the storage required for $\bar{K^3}$ though, which begs the question,
``Does this extra space aid in accuracy or runtime?''.

%The star trios in the catalog star candidates represent potential catalog maps for the image star trio $(b_i, b_j,
%b_c)$.
%Liebe's original method states that this process should be repeated for all stars in the image, meaning that all
%stars will be the central star at one point
%By the end, each star in the image will have accrued a set of possible catalog matches $Y$.
%The complete $I \rightarrow R$ map is found by picking the most frequent catalog star appearing in each $Y$
%set~\cite{liebe:starTrackersAttitudeDetermination,bratt:analysisStarIdentification}.
%
%To more closely follow the generic star identification flow, we modified the Interior Angle method to not store $Y$,
%requiring that only one central star choice is needed to acquire a total match.
%If a confident match is not found by the first central star, then the search process will be repeated until such a
%match is found.

The running time of this algorithm $T_{dot}$ is depicted below, again described in terms of the number of queries
and the number of entries in $\bar{K^3}$:
\begin{equation}\label{eq:dotComplexity}
    T_{dot} = O\left( n \cdot \log(\bar{m_3}) \right)
\end{equation}
where $\bar{m_3}$ is the cardinality of $\bar{K^3}$.

%This entire method is described in~\autoref{algorithm:interiorAngleIdentification}.

\subsection{Spherical Triangle Strategy (SPH)}\label{subsec:sphericalTriangleMethod}
\begin{algorithm}
    \caption{Triangle Identification Strategy} \label{algorithm:triangleIdentification}
    \begin{algorithmic}[1]
        \Function{PartialMatch}{$R, \bar{R}$}
        \ForAll {$\bar{r} \in \bar{R}$}
        \LineComment $\bar{r}$ and $r$ share two stars.
        \If {$\exists \ r \ | \ (r \in R \land |r \cap \bar{r}| = 2)$}
        \State $R_{new} \gets \bar{R} \cup \{\bar{r}\}$
        \EndIf
        \EndFor
        \State \textbf{return} $R_{new}$
        \EndFunction
%        \\
        \Function{Pivot}{$\vv{b_i}, \vv{b_j}, \vv{b_k}, R$}
        \State $b \gets (\vv{b_j}, \vv{b_j}, \vv{b_k})$, $\bar{R} \gets \set{ \bar{r} \mid \bar{r} \in K^3
        \land P_{a, \tau}(\bar{r}, b) }$
        \State $R' \gets $ \Call{PartialMatch}{$R, \bar{R}$}
        \If{$\abs{R'} = 1 \lor \abs{R'} = 0 $}
        \State \textbf{return} $R'$ \Comment $R'$ is either $\emptyset$ or a single $r$.
        \Else
        \State $\vv{\beta} \gets \text{an unused star in this pivot}$
        \State \textbf{return} \Call{Pivot}{$\vv{b_i}, \vv{b_j}, \vv{\beta}, R'$}
        \EndIf
        \EndFunction
%        \\
        \Function{Identify}{$I, K^3$}
        \For{$i \gets 1 \text{\textbf{ to }} n$}  \Comment Iterate through $C(n, 3)$.
        \For{$j \gets i + 1 \text{\textbf{ to }} n - 1$}
        \For{$k \gets j + 1\text{\textbf{ to }} n - 2$}
        \State $b \gets \left(\vv{b_i}, \vv{b_j}, \vv{b_k}\right)$
        \State $R \gets \set{ r \mid r \in K^3
        \land P{a, \tau}(r, b) }$
        \If{$|R| \neq 1$} \Comment Pivot if necessary.
        \State $R \gets $ \Call{Pivot}{$\vv{b_i}, \vv{b_j}, \vv{b_k}, R$}
        \EndIf
        \If{$R \neq \emptyset$} \Comment Verify the pivot's success.
        \State $h \gets $ \Call{DMT}{$b, R_1, I$}
        \invalidBijection
        \State \textbf{return} $b, h$
        \EndIf
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The \textit{Spherical Triangle} strategy is composed of Cole and Crassidus's spherical area and moment features, a
naive $b$ image subset decision, Cole and Crassidus's candidate selection process, and a direct-match test to create
the image to database function.

Given a set of stars from the image $I$, $d \seq 3$ stars are selected to obtain the $b$ set in the same
straightforward manner as the Angle strategy.
%Again, the $b$ selection is not specified here so we assume the naive approach with $C(n, 3)$ combinations.
For $C(n, 3)$ combinations the star $\vv{b_1}$ is fixed in $b$ for $n^2$ image star subset selections,
the star $\vv{b_2}$ is fixed for $n$ selections, and the last star $\vv{b_3}$ is constantly changed for
every new $b$ choice.

The $R$ retrieval step searches the $K^3$ set for trios such that the spherical area and moment of the database
trios are close to the spherical area and moment of the image star
subset~\cite{coleAndCrassidis:sphericalTriangleMethod}.
For the image star subset, the spherical area and moment are represented as $a(b)$ and $\tau(b)$ respectively.
For the database star candidate set, these same features are represented as $a(r)$ and $\tau(r)$.
To obtain $R$, the predicate $P_{a, \tau}(r, b)$ is used to filter $K^3$:
\begin{equation}
    \begin{aligned}
        P_{a, \tau}(r, b) : \abs{ a(r) - a(b)} &< 3\sigma_{a}
        \ \land \\ \abs{\tau(r) - \tau(b)} &< 3\sigma_{\tau}
    \end{aligned}
\end{equation}
where $\sigma_{a}$ and $\sigma_{\tau}$ represent the deviation of the uncertainty between the $a$ and $\tau$
computations with the star sensor measurements and the same $a$ and $\tau$ computations with stars defined in the
database.

Unlike the previous two strategies, the $R$ criterion of $|R| \seq 1$ not being met does not lead to an immediate new
selection of $b$.
Instead, the candidate set itself is reduced by \textit{pivoting} until the criterion is met or pivots can no longer
be performed.
The pivoting procedure starts by searching the database again for a second set of database candidate sets $\bar{R}$ with
a different image star subset $\bar{b} \seq \left(\vv{b_i}, \vv{b_j}, \vv{\beta}\right)$.
In $\bar{b}$, the first two stars are held constant while the third star is swapped with another in $I$ that was not
already used in this specific pivot.
All star trios in the initial search that do not match a trio in the second search by \textit{two stars} (a partial
match) are removed from the initial search candidate star set~\cite{coleAndCrassidis:sphericalTriangleMethod}.
A pivot uses at most $n - 3$ additional database accesses, but prevents wasting an $R$ set that may contain
the correct $r$ set for the given $b$.

\begin{algorithm}
    \caption{Pyramid Identification Strategy} \label{algorithm:pyramidIdentification}
    \begin{algorithmic}[1]
        \Function{FC}{$T_1, T_2$}
        \LineComment Flatten $T_1, T_2$ from set of sets to a set.
        \State $\bar{T_1} \gets \emptyset, \bar{T_2} \gets \emptyset$
        \ForAll{$i \in \set{1, 2}$}
        \ForAll{$\vv{t} \in T_i$}
        \State $\bar{T_i} \gets \bar{T_i} \cup \set{ \vv{t_1}, \vv{t_2} }$
        \EndFor
        \EndFor
        \State \textbf{return} $\bar{T_1} \cap \bar{T_2}$
        \EndFunction
        %        \\
        \Function{FindT}{$\vv{b^1}, \vv{b^2}, \vv{b^3}, K^2$}
        \LineComment $\abs{\vv{b^1}} = \abs{\vv{b^2}} = \abs{\vv{b^3}} = 1$, search with each pair.
        \State $T_1 \gets \set{ r \mid r \in K^2 \land P_\theta \left(r, b^1\right) }$
        \State $T_2 \gets \set{ r \mid r \in K^2 \land P_\theta \left(r, b^2\right) }$
        \State $T_3 \gets \set{ r \mid r \in K^2 \land P_\theta \left(r, b^3\right) }$
        \State \textbf{return}{$\left( T_1, T_2, T_3 \right)$}
        \EndFunction
        %        \\
        \Function {Retrieve}{$b, K^2$}
        \State $(T_{ij}, T_{ik}, T_{jk}) \gets$ \Call{FindT}{$\set{ \vv{b_i}, \vv{b_j} }, \set{ \vv{b_i}, \vv{b_k} }, $
        \State \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
        $\set{ \vv{b_j}, \vv{b_k} }, K^2$}, $R \gets \emptyset$
        \ForAll{$t_i \in$ \Call{FC}{$T_{ij}, T_{ik}$}}
        \ForAll{$t_j \in$ \Call{FC}{$T_{ij}, T_{jk}$}}
        \ForAll{$t_k \in$ \Call{FC}{$T_{ik}, T_{jk}$}}
        \State $R \gets R \cup \set{ \left(\vv{t_i}, \vv{t_j}, \vv{t_k}\right) }$
        \EndFor
        \EndFor
        \EndFor
        \State \textbf{return} $R$ \Comment Return all permutations from $T$ sets.
        \EndFunction
        %        \\
        \Function{Identify}{$I, K^2$}
        \LineComment Iterate through $C(n, 3)$ while avoiding false stars.
        \For{$dj \gets 1 \text{\textbf{ to }} n - 2$} \label{algline:pyramidI}
        \For{$dk \gets 1 \text{\textbf{ to }} n - 1 - dj$} \label{algline:pyramidJ}
        \For{$i \gets 1 \text{\textbf{ to }} n - dj - dk$} \label{algline:pyramidK}
        \State $j \gets i + dj$, $k \gets j + dk$
        \State $b \gets \left(\vv{b_i}, \vv{b_j}, \vv{b_k}\right)$, $R \gets $\Call{Retreive}{$b, K^2$}
        \If{$\abs{R} = 1$}
        \LineComment Verification step below.
        \State $\vv{\beta} \gets $ single star in $I$ where $\vv{\beta} \notin b$
        \State $(T_{ij}, T_{ik}, T_{jk}) \gets$ \Call{FindT}{$\set{ \vv{b_i}, \vv{\beta} }, \set{ \vv{b_j},
        \vv{\beta} },$
        \State \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ $\set{ \vv{b_k}, \vv{\beta} }, K^2$}
        \State $T_\beta \gets $ \Call{FC}{$T_{i\beta}, T_{j\beta}$} $\cap$ \Call{FC}{$T_{j\beta}, T_{k\beta}$}
        \If{ $\abs{T_\beta} = 1$}
        \State \textbf{return} $b, h \mid h(b_1) = r_1, \ h(b_2) = r_2$
        \State \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $h(b_3) = r_3$
        %        \State \textbf{return} $b, r, h: \vv{b_1} \mapsto \vv{r_1}, \vv{b_2} \mapsto \vv{r_2},$
        \EndIf
        \EndIf
        \EndFor
        \EndFor
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{subequations}
    The \Call{DMT}{} process is used to complete the star identification process here.
    Given an image star trio and a database star trio, a injection is proposed:
    \begin{equation}
        h_1 \mid h_1(b_1) = r_1, \ h_1(r_2) = r_2, \ h_1(b_3) = r_3
    \end{equation} \label{eq:trianglePossibleMaps}
    The TRIAD method only uses two vector observations from each frame, meaning that the $(b_3, r_3)$
    pairing is disregarded as the first rotation $A_1$ is computed.
    This process is repeated for all 5 other possible injections to get $A_2, A_3, \dots, A_6$.
    \begin{align}
        h_2 &\mid h_2(b_1) = r_1, \ h_2(r_2) = r_3, \ h_2(b_3) = r_2 \\
        h_3 &\mid h_3(b_1) = r_2, \ h_3(r_2) = r_1, \ h_3(b_3) = r_3 \\
        h_4 &\mid h_4(b_1) = r_2, \ h_4(r_2) = r_3, \ h_4(b_3) = r_1 \\
        h_5 &\mid h_5(b_1) = r_3, \ h_5(r_2) = r_1, \ h_5(b_3) = r_2 \\
        h_6 &\mid h_6(b_1) = r_3, \ h_6(r_2) = r_2, \ h_6(b_3) = r_1
    \end{align}
\end{subequations}
For all six attitudes, the injection yielding the most aligned stars is returned.

The running time of this algorithm $T_{sphere}$ is depicted below in terms of the number of queries and the number of
entries in the $K^3$ database.
At most, this requires $2n^4$ database accesses: $n^3$ for each combination of trios in $I$, $n - 3$ potential database
accesses incurred for each pivot, and an additional $n^4$ queries with each \Call{DMT}{} call.
\begin{equation}\label{eq:sphereComplexity}
    T_{sphere} = \bigO\left( n^4 \cdot \log (m_3) \right)
\end{equation}
where $m_3$ is the cardinality of $K^3$.

%This entire method is described in~\autoref{algorithm:triangleIdentification}.

\subsection{Planar Triangle Strategy (PLN)}\label{subsec:coleAndCrassidus'sPlanarTriangleMethod}
The \textit{Planar Triangle} strategy is identical to their Spherical Triangle strategy, with the exception that each
image trio is represented as a planar triangle instead of a spherical one.
This results in the computation of a planar area and moment as opposed to a spherical area and moment.

\subsection{Pyramid Strategy (PYR)}\label{subsec:pyramidMethod}
The \textit{Pyramid} strategy is composed of Mortari's $b$ image subset decision, a custom voting based identification
process for star trios, and a voting based verification step.

Given a set of stars from the image $I$, $d \seq 3$ stars are selected to obtain the $b$ set.
The selection order is governed by lines~\ref{algline:pyramidI},~\ref{algline:pyramidJ}, and~\ref{algline:pyramidK}
in~\autoref{algorithm:pyramidIdentification}.
As opposed to the selection order of the Angle and triangle strategies, the $\vv{b_1}$ star in $b$ is no longer fixed
for $n$ or $n^2$ image star subset selections.
This is meant to avoid the persistence of misleading stars for more than a few combinations
~\cite{mortari:pyramidIdentification}.
An example sequence of trios is depicted below for $n \seq 5$ stars.
\begin{equation}
    \begin{aligned}
        C(5, 3) \text{ of } I = ( &\set{\vv{I_1}, \vv{I_2}, \vv{I_3}}, \set{\vv{I_2}, \vv{I_3}, \vv{I_4}}, \\
        &\set{\vv{I_3}, \vv{I_4}, \vv{I_5}}, \set{\vv{I_1}, \vv{I_2}, \vv{I_4} }\ldots )
    \end{aligned}
\end{equation}

%The literature states that a unique and identifiable trio is to be found after the query step using $\theta$,
%but does not specify how nor is source code provided.
The approach developed here was inspired by the two star voting algorithm, which accumulates "votes" for some star by
determining the angle between the same star and two other stars~\cite{tichy:preliminaryTestsCommericalImagers}.
We start by retrieving pairs from $K^2$ such that the angular separations of the database pairs are
close to the angular separation of the image pair $\set{\vv{b_i}, \vv{b_j}}$.
This is repeated for the other two permutations $\set{\vv{b_i}, \vv{b_k}}$ and $\set{ b_j, \vv{b_k} }$ to obtain
the sets $T_{ij}, T_{ik}$ and $T_{jk}$ respectively.
These sets are then flattened from sets of pairs to just a single set of stars (\Call{FC}{}
in~\autoref{algorithm:pyramidIdentification}) and the difference of two flattened sets identify candidates for that
star.
For the sets of pairs $T_{ij}, T_{jk}$ found by searching $K^2$ with $P_\theta$ and $\set{\vv{b_i}, \vv{b_j}},
\set{\vv{b_j}, \vv{b_k}}$, the common star between each $b$ set is $\vv{b_j}$.
An example of finding database candidates for $b_j$ with this method is given below:
\begin{equation}
    \begin{aligned}
        T_{ij} \gets& \set{ \set{\vv{K_{1123}}, \vv{K_{9001}}}, \set{\vv{K_{8234}}, \vv{K_{33}}} } \\
        T_{jk} \gets& \set{ \set{\vv{K_{612}}, \vv{K_{1123}}}, \set{\vv{K_{33}}, \vv{K_{345}}} } \\
        T_j =& \  \Call{FC}{T_{ij}, T_{jk}} = \set{\vv{K_{1123}}, \vv{K_{33}}}
    \end{aligned}
\end{equation}
$R$ is found by repeating the process above for $T_i$ and $T_k$, and generating all possible sequences.
This is depicted in the \Call{Retrieve}{} function in~\autoref{algorithm:pyramidIdentification}.

After finding some $R$ where $\abs{T_i} \seq \abs{T_j} \seq \abs{T_k} \seq 1$ (same criterion as Angle and
Interior Angle), a verification step is performed.
A different star from the image $\vv{\beta}$ is selected and the $R$ retrieval step is performed for each distinct trio
combination of $b$ and $\vv{\beta}$.
If $\abs{T_\beta} \neq 1$, then verification step has failed and another image subset is selected.
Otherwise, the injection with mapping $h(b_1) = r_1 \ h(b_2) = r_2 \ h(b_3) = r_3$ is returned.
Like the Interior Angle strategy, a star mapping procedure is not required to determine $h$.
Instead, each individual star is identified at $R$ retrieval time.

The running time of this algorithm $T_{pyramid}$ is depicted below in terms of the number of queries and the number
of elements in $K^2$.
At most, this requires $6n^3$ database accesses: $3n^3$ accesses for each $T$ retrieval with an additional
$3n^3$ accesses for each verification step.
\begin{equation}
    T_{pyramid} = \bigO \left( n^3 \cdot \log( m_2 ) \right)
\end{equation}
where $m_2$ is the cardinality the $K^2$.

%This entire method is specified in~\autoref{algorithm:pyramidIdentification}.

%\begin{algorithm}
%    \caption{Composite Pyramid Identification Method}\label{algorithm:compositePyramid}
%    \begin{algorithmic}[1]
%        \Function{Identify}{$I, K^3$}
%        \LineComment Iterate through $C(n, 3)$ while avoiding false stars.
%        \For{$dj \gets 1 \text{\textbf{ to }} n - 2$}
%        \For{$dk \gets 1 \text{\textbf{ to }} n - 1 - dj$}
%        \For{$i \gets 1 \text{\textbf{ to }} n - dj - dk$}
%        \State $j \gets i + dj$, $k \gets j + dk$
%        \State $b \gets (\vv{b_i}, \vv{b_j}, \vv{b_k})$
%        \State $R \gets \set{ r \mid r \in K^3 \land P{a, \tau}(r, b) }$
%        \If{$\lvert R \rvert = 1$}
%        \LineComment Verification step below.
%        \State $\beta \gets $ single star in $I$ where $\beta \notin b$
%        \State $T_{12\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau}(r, \set{\vv{b_1}, \vv{b_2}, \vv{\beta}})}$
%        \State $T_{13\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau}(r, \set{\vv{b_1}, \vv{b_3}, \vv{\beta}})}$
%        \State $T_{23\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau} (r, \set{\vv{b_2}, \vv{b_3}, \vv{\beta}})}$
%        \State $T_\beta \gets $ \Call{FC}{$T_{12\beta}, T_{13\beta}$} $\cap$ \Call{FC}{$T_{j13\beta}, T_{23\beta}$}
%        \If{$\abs{T_\beta} = 1$}
%        \State $h \gets$ \Call{DMT}{$b, R_1, I$}
%        \invalidBijection
%        \State \textbf{return} $h$
%        \EndIf
%        \EndIf
%        \EndIf
%        \EndFor
%        \EndFor
%        \EndFor
%        \EndFunction
%    \end{algorithmic}
%\end{algorithm}

\subsection{Composite Pyramid Strategy (COM)}\label{subsec:compositePyramidMethod}
The \textit{Composite Pyramid} strategy is composed of Mortari's $b$ image subset decision, Cole and Crassidus's
spherical area and moment features, and a voting based verification step.

Given a set of stars from the image $I$, $d \seq 3$ stars are selected in same manner as the Pyramid strategy to obtain
the $b$ set.
From here, the process to obtain the $R$ set is the same as the triangle strategies: use $P_{a, \tau}(r, b)$ and $b$ to
select all candidates from $K^3$.
If the current $R$ set meets the same $\abs{R} \seq 1$ criterion, then a similar verification step to the Pyramid
strategy is performed with the Planar Triangle features.
Once this test has passed, the \Call{DMT}{} method is used to construct the injection $h$ to potentially return.
The Pyramid strategy did not need this call as an implicit injection was formed through its $R$ retrieval process.

The running time of this algorithm $T_{composite}$ is depicted below in terms of number of queries and the number
of elements in $K^3$.
At most, this requires $5n^3$ database accesses: $n^3$ for each $T$ retrieval, an additional $3n^3$ accesses for each
verification step, and an additional $n^3$ accesses for each \Call{DMT}{} call.
\begin{equation}
    T_{composite} = \bigO (n^3 \cdot \log(m_3))
\end{equation}
where $m_3$ is the cardinality of $K^3$.

%This entire method is specified in~\autoref{algorithm:compositePyramid}.

%\begin{table*}[ht]
%    \centering{
%    \caption{
%    Overview table of the different identification methods.
%    Each method's image features, reduction process, identification process is displayed.
%    } \label{tab:identificationMethodOverview}
%    \input{include/floats/summary-table}
%    }
%\end{table*}
