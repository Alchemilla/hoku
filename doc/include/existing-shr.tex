\newcommand{\algorithmautorefname}{Algorithm}

\newcommand{\algeqref}[1]{\hyperref[#1]{Eq.~\ref*{#1}}}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\algrenewcommand\algorithmicindent{0.35cm}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\MakeRobust{\Call}

\newfloat{algorithm}{t}{lop}
\restylefloat{algorithm}

\section{Constellation Query Processing Strategies}\label{sec:starIdentificationMethods}
%This section serves to describe our unified framework and a high-level overview of how six different approaches both adhere to this framework \& how they differ from each other.
%Six different approaches to constellation query processing are described in this section.
%When the description did not specify a step in this flow, a simple or existing approach from another strategy was used.
%Several deviations to the algorithms from the original literature were introduced from newer literature to evaluate
%the effectiveness of these changes.

\subsection{Unified Identification Strategy Framework}\label{subsec:unifiedIdentification}
Each constellation query is presented with a set of points from an image
$\imageset$ of size $n$ as well as a database containing two relations: $\texttt{REF}$ 
holds the collection of all known points indexed by some
identifier, and $R$ holds sets of these known points indexed by one or
more features of the set itself.  Elements in $R$ are henceforth referred
to as $r$ sets, with $\abs{r}\seq d$. 
The resultant is an $d$-sized subset of points from the image known as the $b$
set, as well as a mapping from this subset to the database.  Identification
of all points in each image is not the focus.

To start, all strategies begin by choosing a $b$ set from the image $\imageset$.
$r$ sets are then retrieved from $R$ using some predicate dependent on the current $b$.
If there exists only one $r$ as a result, then we proceed.
Otherwise, we loop back to the first step and select a different subset of $d$ stars.
Certain methods may also choose to invoke a secondary database retrieval utilizing a new database set to filter the current $r$ before deciding to choose a different $b$ altogether.
Once we have found a unique $r$ set, we determine a mapping between this set and $b$.
If we are confident in this map, we return this function along with the current $b$ set.
Otherwise, we loop back to the start and choose another $b$ set.
This process is depicted in~\autoref{figure:unifiedIdentificationFlowchart}.
In the event we exhaust all possible $b$ sets, an error is raised and no map is returned.

%Every algorithm starts with some combination from all possible $d$ combinations of $n$ points, where $d$ is the size of the image subset specified by the specific identification strategy.
%The image subset $\imagesubset$ is selected using one of these combinations.
%For a strategy that uses $d\seq2$ points to determine the mapping in an image of $n\seq 4$ points, the 6 combinations of $\imageset$ are given as $\binom{\imageset}{d}$:
%\begin{equation}
%    \begin{aligned}
%	    \binom{\imageset}{d} = \{&
%	    	\set{\vv{\imageset[1]}, \vv{\imageset[2]}},
%	    	\set{\vv{\imageset[1]}, \vv{\imageset[3]}}, \\
%	       &\set{\vv{\imageset[1]}, \vv{\imageset[4]}}, \ldots,
%	        \set{\vv{\imageset[3]}, \vv{\imageset[4]}}
%	        \}
%    \end{aligned}
%\end{equation}

%Each identification method $\texttt{X}$ is also presented a set $\genericdatabase$, composed of $d$ sized sets of all possible combinations or permutations of points from $\databaseset$.
%Using certain features of the image subset, the entire $\genericdatabase$ set is filtered to a set of star sets $\databasesubset$.
%This is known as the \emph{candidate retrieval step}.
%Referencing the same $d\seq 2$ strategy as before, an image subset $\imagesubset \seq \set{\vv{\imageset[1]}, \vv{\imageset[2]}}$ may yield the candidates in~\autoref{eq:catalogCandidateExample}:
%\begin{equation}
%	\label{eq:catalogCandidateExample}
%    \databasesubset = \set{ \set{\vv{\databaseset[104]}, \vv{\databaseset[899]}}, \set{\vv{\databaseset[7622]}, \vv{\databaseset[7771]}}, \ldots) } 
%\end{equation}

%Through some filter process for $\databasesubset$ and/or loop back to the $b$ selection step until $\abs{R} = 1$, a single set $\candidateset$ from the database candidates is  chosen.
%This is known as the \emph{candidate selection step}.
%The candidate selected here refers to a database star set that is likely to align with the current image subset.
%For a process that only loops back to the $b$ selection step until the $|\databasesubset| \seq 1$ criterion holds true, the following sequence of events may occur.
%The notation $\databasesubset^{(t)}$ and $\imagesubset^{(t)}$ denotes distinct $\genericdatabase$ and $\imageset$ subsets here, as opposed to the notation $\databasesubset[j]$ and $\imagesubset[j]$ which denotes singular database candidates and single points in $\imageset$ respectively.
%\begin{description}[noitemsep]
%    \item[$t = 1:$] $\text{ query with } b^{(1)}, \text{ get } R^{(1)} = \{\vv{r_{11}}, \vv{r_{12}}, \ldots\}.$
%    \item[$t = 2:$] $\abs{ R^{(1)} } \neq 1, \text{ criterion not met. }$
%    \item[$t = 3:$] $\text{ choose new image subset } b^{(2)}.$
%    \item[$t = 4:$] $\text{ query with } b^{(2)}, \text{ get } R^{(2)} = \{\vv{r_{21}}\}.$
%    \item[$t = 5:$] $\abs{ R^{(2)} } = 1, \text{ criterion met. }$
%    \item[$t = 6:$] $\text{ return } r, r \in R^{(2)} (\text{sole element in } R^{(2)} ).$
%\end{description}
%\begin{align*}
%    &t = 1, \text{ retrieve with } \imagesubset^{(1)}, \text{ get } \databasesubset^{(1)} = \{\vv{\candidateset_{11}}, \vv{\candidateset_{12}}, \ldots\}. \\
%    &t = 2, \ \abs{ \databasesubset^{(1)} } \neq 1, \text{ criterion not met. } \\
%    &t = 3, \text{ choose new image subset } \imagesubset^{(2)}. \\
%    &t = 4, \text{ retrieve with } \imagesubset^{(2)}, \text{ get } \databasesubset^{(2)} = \{\vv{\candidateset_{21}}\}. \\
%    &t = 5, \ \abs{ \databasesubset^{(2)} } = 1, \text{ criterion met. } \\
%    &t = 6, \text{ return } \candidateset, \candidateset \in \databasesubset^{(2)} (\text{sole element in } \databasesubset^{(2)} ).
%\end{align*}

%\begin{algorithm}
%	\caption{Direct Match Testing} \label{algorithm:dmt}
%	\begin{algorithmic}[1]
%		\Function{FPO}{$\texttt{DB\_NEAR}$, $\imageset$, $A$}
%		\State $\texttt{IMG\_ROT} \gets$ points in $\imageset$ rotated by $A$
%		\State \textbf{return} \parbox[t]{0.8\linewidth}{\raggedright all points in $\texttt{DB\_NEAR}$ that overlap with some point in $\texttt{IMG\_ROT}$}
%		\EndFunction
%		\\
%        \Function{DMT}{$b, r, \imageset, \databaseset$}
%        \State $\texttt{DB\_NEAR} \gets $ all points in $\databaseset$ near $r$
%        \State $\texttt{DB\_MATCH} \gets \emptyset$
%        \For {$h \in $ all possible mappings between $b$ and $r$}
%        \State $A \gets $ \Call{TRIAD}{$h, \imagesubset, \candidateset$}
%        \State $\texttt{DB\_MATCH}_h \gets $ \Call{FPO}{$\texttt{DB\_NEAR}, \imageset, A$}
%        \EndFor
%        \If{there exists no largest set $\texttt{DB\_MATCH}_h \in \texttt{DB\_MATCH}$}
%        \State \textbf{return} an invalid function %\Comment Indicate non-confidence.
%        \Else
%        \State \textbf{return} $h \in H$ associated with largest set in $\texttt{DB\_MATCH}$
%        \EndIf
%        \EndFunction
%	\end{algorithmic}
%\end{algorithm}

\newcommand{\smapsto}{\! \mapsto \!}
%\begin{subequations}
%	From here, a mapping $\solutionmap$ is determined that pairs each point found in the image subset to a single point in the database candidate set.
%	For brevity, it is assumed that all functions in this paper have domain $\imagesubset$ and codomain $\databaseset$.
%	Most (but not all) of the following queries utilize Tappe's implementation of the strategy and perform a \textit{direct match test}, abbreviated henceforth as DMT~\cite{tappe:starTrackerDevelopment,needelman:stellarAttitudeAcquisition}.
%    Given an image pair $\imagesubset$ and a database pair $\candidateset$, the following is proposed:
%    \begin{equation}
%        \solutionmap_1 \mid \solutionmap_1(\imagesubset[1]) = \candidateset[1], \ \solutionmap_1(\imagesubset[2]) = \candidateset[2]
%    \end{equation}
%    Wahba's problem is then solved using the TRIAD method to obtain a rotation $A_1$ between the image and database coordinate systems.
%    The \Call{TRIAD}{} function accepts a mapping $\solutionmap$, an image subset $\imagesubset$, a candidate set $\candidateset$, and outputs a rotation matrix $A$.
%    This process is repeated for the other possible permutation to obtain a second rotation $A_2$:
%    \begin{equation}
%        \solutionmap_2 \mid \solutionmap_2(\imagesubset[1]) = \candidateset[2], \ \solutionmap_2(\imagesubset[2]) = \candidateset[1]
%    \end{equation}
%\end{subequations}
%The most likely attitude is determined by the \Call{FPO}{} (short for \textit{Find Positive Overlay}) method, which returns how many points from $\imageset$ align with $\databaseset$ given rotation $A_1$ or $A_2$.
%The mapping with the most aligned points is then returned, and our query is completed.
%If there exists no singular mapping which gives us a largest set, we signal our lack of confidence to our caller by returning an invalid function.
%This process is detailed in~\autoref{algorithm:dmt}.
%
%If we are not confident in $h$ at this stage, another image subset is chosen and the process is repeated.
%This entire flow is detailed in~\autoref{figure:unifiedIdentificationFlowchart}.
%In the event $\binom{\imageset}{d}$ has been exhausted, an error is raised and no map is returned.

% Leaving this out for now. The flowchart should explain the process better.
%\begin{algorithm}[ht] \setstretch{1.0}[H]
%    \caption{Generic Star Identification Method} \label{algorithm:genericStarIdentification}
%    \begin{algorithmic}[1]
%        \Procedure{Identify}{}
%        \State $I \gets $ all stars from image
%        \For{$c \in r_k^{|I|}$}
%        \State $b \gets \{I(c_1), I(c_2), I(c_3), \dots, I(r_k)\}$
%        \State $R \gets $ catalog star sets, each set of size $=k$
%        \State $r \gets $ a single set from $R$ that matches $b$
%        \State $a \gets $ a map between $b$ and $r$
%        \\
%        \If{the steps above are successful}
%        \State \textbf{return} $a$
%        \EndIf
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

% Citation: https://digitalcommons.usu.edu/cgi/viewcontent.cgi?article=2723&context=etd AND Gottlieb.
\subsection{Overview of Strategies}\label{subsec:strat}
We discuss six strategies in this section: the Angle strategy (ANG), the Interior Angle strategy (INT), the Spherical Triangle strategy (SPH), the Planar Triangle strategy (PLN), the Pyramid strategy (PYR), and the Composite Pyramid strategy (COM).

%\subsection{Angle Strategy (ANG)}\label{subsec:angleMethod}
\newcommand{\invalidBijection}{\If{$\solutionmap$ is valid}}
%\begin{algorithm}
%    \caption{Angle Identification Strategy} \label{algorithm:angleIdentification}
%    \begin{algorithmic}[1]
%    	\Function{RetrieveCandidates}{$b, \angdatabase$}
%    	\State \textbf{return} $\{ \candidateset \mid \candidateset \in \angdatabase \land P_\theta(\candidateset, \imagesubset) \}$
%    	\EndFunction
%        \\
%        \Function{Identify}{$b, R, \imageset, \databaseset$}
%        \State $r \gets R[1]$ \Comment Select our candidate.
%        \State \textbf{return} \Call{DMT}{$\imagesubset, r, \imageset, \databaseset$}
%        \EndFunction
%        \\
%        \Procedure{Query}{$\imageset, \angdatabase, \databaseset$}
%        \For{$i \gets 1 \text{\textbf{ to }} n$} \label{algline:angleI}
%        \For{$j \gets i + 1 \text{\textbf{ to }} n - 1$} \label{algline:angleJ}
%        \State $\imagesubset \gets \left(\vv{\imageset[i]}, \vv{\imageset[j]}\right)$ \Comment Pick $d=2$ points. 
%        \State $\databasesubset \gets $ \Call{RetrieveCandidates}{$b, \angdatabase$}
%        \If{$\abs{R} = 1$} \Comment Verify cardinality.
%        \State $h \gets \Call{Identify}{b, R, \imageset, \databaseset}$
%        \invalidBijection \Comment Confidence check.
%        \State \textbf{return} $\imagesubset, \solutionmap$
%        \EndIf
%        \EndIf
%        \EndFor
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

The \textit{Angle} strategy is composed of a naive image subset $\imagesubset$ decision, angular features of pairs first described by Gottlieb's Polygon Angular Matching strategy, and a direct-match test for identification.
Given a set of points from an image $\imageset$, our query starts by selecting two distinct points to represent the $b$ set.
To naively select some $b$ is to fix the point $b_1 \in \imagesubset$ for $n$ image subset selections, while constantly changing $b_2$ for every new $\imagesubset$ choice.
%\begin{equation}
%\begin{aligned}
%		\text{1st } b &= \{ \imageset[1], \imageset[2] \} \\
%	\text{2nd } b &= \{ \imageset[1], \imageset[3] \} \\
%	n\text{th } b &= \{ \imageset[1], \imageset[n] \} \\
%	(n + 1)\text{th } b &= \{ \imageset[2], \imageset[3] \} \\
%	P(n, 2)\text{th } b &= \{ \imageset[n - 1], \imageset[n] \}
%\end{aligned}
%\end{equation}
Now having an image subset, the next step involves creating the predicate to search for $r$ sets with.
Let $\texttt{REF}_\texttt{ANG}$ define a relation holding tuples of all combinations of two \texttt{REF} identifiers, indexed by the angular separation between both \texttt{REF} points.
The Angle method performs a range search across $\texttt{REF}_\texttt{ANG}$ for all $r$ sets such that the angular separation defined in $\texttt{REF}_\texttt{ANG}$ is close to the separation between the image subset~\cite{bratt:analysisStarIdentification}.
If our database search yields a single $r$ set, we proceed to the last step: finding a mapping through a process known as the direct-match test.
Tappe's implementation of this procedure iterates through all possible maps, transforms the image to the standard coordinate system using this pairing, and chooses the map with the most amount of image points close to some database point~\cite{tappe:starTrackerDevelopment,needelman:stellarAttitudeAcquisition}.
In the event both maps possess no matching database points other than those in $r$, we return to the image subset selection step.

%To determine the most likely mapping $h$, we perform \Call{$DMT$}{} with $b$ and $r$ to either get a map between every element in $b$ to $r$, or an invalid map signaling us to repeat the query for another image set and candidate.

%Given a set of query points from the image $\imageset$, $d \seq 2$ points are selected to obtain the $\imagesubset$ set.
%The selection order is governed by lines~\ref{algline:angleI} and~\ref{algline:angleJ} in~\autoref{algorithm:angleIdentification}.
%This fixes the point $\vv{\imagesubset[1]}$ in $\imagesubset$ for $n$ image subset selections, while constantly changing $\vv{\imagesubset[2]}$ for every new $\imagesubset$ choice.
%An example sequence of pairs is depicted below for $n \seq 3$ points.
%\begin{equation}
%    \binom{\imageset}{2} = \left(\set{\vv{\imageset[1]}, \vv{\imageset[2]}}, \set{\vv{\imageset[1]},\vv{\imageset[3]}}, \ldots \right)
%\end{equation}

%For the Angle strategy, $\genericdatabase$ of the unified framework refers to the $\angdatabase$ set: a set of all possible pairs of points in $\databaseset$.
%The candidate retrieval step searches the $\angdatabase$ set for pairs such that the angular separations of the database pairs are close to the separations of the image subset~\cite{bratt:analysisStarIdentification}.
%For the image subset, the origin of the separation calculation $\theta(\imagesubset)$ is the focal point of the lens itself.
%For a database candidate set, the origin of this calculation $\theta(\candidateset)$ is the center of the Earth.
%To obtain $\databasesubset$, the predicate $P_\theta(\candidateset, \imagesubset)$ is used to filter the $\angdatabase$ database, where $\candidateset \in \databasesubset$:
%\begin{equation}\label{eq:angleRequirement}
%    P_{\theta}(\candidateset, \imagesubset) : \left\lvert \theta(\candidateset) - \theta(\imagesubset)\right\rvert < \epsilon_\theta
%\end{equation}
%where $\epsilon_{\theta}$ represents the uncertainty between the $\theta$ computation with star
%sensor measurements and the same $\theta$ computation with points defined in the database.
%Once the database candidates are obtained, the $\abs{\databasesubset} \seq 1$ criterion is imposed, repeating this process until only one set exists in $\databasesubset$.
%This sole element $\vv{\databasesubset[1]}$ is then selected to be our candidate $r$.
%To determine the most likely mapping $h$, we perform \Call{$DMT$}{} with $b$ and $r$ to either get a map between every element in $b$ to $r$, or an invalid map signaling us to repeat the query for another image set and candidate.

%The \Call{FPO}{} method determines the number of stars from $I$ in the body frame $\iFrame$ align with $C$ in the
%inertial frame $\kFrame$.
%More stars are selected from the catalog that are near the original subset $r$, denoted as $P$.
%The \Call{FPO}{} method then filters out stars in set $P$ that do not overlay with some star in $I'$, the image set
%rotated by some rotation $q$.
%An additional term $\sigma_o$ is defined, which defines how selective this filter.
%$\sigma_o$ can also be thought of as an assumption of the noise associated with the rotation $q$.

%Accessing the database is the most expensive operation for all of the identification strategies.
%Consequently, the running time of this algorithm $T_\texttt{ANG}$ can be described in terms of the number of database accesses and the number of elements that exist in $\angdatabase$.
%There exist $2n^2$ database accesses at worst, requiring two database accesses (candidate retrieval step and \Call{DMT}{} calls) for each combination of pairs in $\imageset$.
%The $\log (m_\texttt{ANG})$ term describes the number of comparisons until $\candidateset$ sets are found in our database and are able to be returned.
%Given a B+ tree indexed relation with $\abs{\angdatabase}\seq m_\texttt{ANG}$ elements, no more than $\bigO \left( \log(m_\texttt{ANG}) \right)$ comparisons are required~\cite{patel:advanceTreeStructures}.
%\begin{equation}\label{eq:complexityAnglePart1}
%    T_{angle} = \bigO\left(C(n, 2) \cdot n \cdot \log(m_{angle}) \right)
%\end{equation}
%We expand the combination term to get:
%\begin{equation}
%    C(n, 2) = \frac{n(n - 1)}{2} = \frac{n^2}{4} - \frac{n}{4}
%\end{equation}
%~\autoref{eq:complexityAnglePart1} then simplifies to~\autoref{eq:complexityAngle}:
%\begin{equation}\label{eq:complexityAngle}
%    T_{\texttt{ANG}} = \bigO\left( n^2 \cdot \log(m_\texttt{ANG}) \right)
%\end{equation}

%All methods associated with the Angle method are written in~\autoref{algorithm:angleIdentification}.

%\subsection{Interior Angle Strategy (INT)}\label{subsec:interiorAngleMethod}
%\begin{algorithm}
%    \caption{Interior Angle Identification Strategy} \label{algorithm:interiorAngleIdentification}
%    \begin{algorithmic}[1]
%    	\Function{RetrieveCandidates}{$b, \intdatabase$}
%    	\State \textbf{return} $\set{ \candidateset \mid \candidateset \in \intdatabase \land P_{\theta, \phi}(\candidateset, \imagesubset) }$
%    	\EndFunction
%        \\
%        \Function{Identify}{$b, R$}
%        \State $r \gets R[1]$ \Comment Select our candidate.
%        \State \textbf{return} $\imagesubset, \solutionmap \mid \solutionmap(\imagesubset[1]) = \candidateset[1], \ \solutionmap(\imagesubset[2]) = \candidateset[2], \ \solutionmap(\imagesubset[3]) = \candidateset[3]$
%%        \State \textbf{return} $\imagesubset, \solutionmap \mid $ \parbox[h]{0.7\linewidth}{\raggedright $\solutionmap(\imagesubset[1]) = \candidateset[1], \ \solutionmap(\imagesubset[2]) = \candidateset[2], \newline \ \solutionmap(\imagesubset[3]) = \candidateset[3]$}
%        \EndFunction
%    	\\
%        \Procedure{Query}{$\imageset, \intdatabase$}
%        \For{$c \gets 1 \text{\textbf{ to }} n$} 
%        \State $\vv{\imagesubset[1]} \gets \imageset[c]$ \Comment Pick $d=3$ points.
%        \State $\vv{\imagesubset[2]} \gets $ closest star to $b[1]$
%        \State $\vv{\imagesubset[3]} \gets $ 2nd closest star to $b[1]$
%%        \State $\theta_\texttt{IMG\_C} \gets \{\theta(\vv{\imageset[c]}, \vv{\imageset[i]}) \mid \vv{\imageset[i]} \in \imageset\}$ 
%%        \State $\vv{\imagesubset[2]} \gets \vv{\imageset[i]}$ associated with smallest $\theta$ in $\theta_\texttt{IMG\_C}$
%%        \State $\vv{\imagesubset[3]} \gets \vv{\imageset[i]}$ associated with 2nd smallest $\theta$ in $\theta_\texttt{IMG\_C}$
%        \State $\databasesubset \gets $ \Call{RetrieveCandidates}{$b, \intdatabase$}
%        \If{$\abs{R} = 1$}\Comment Verify cardinality. 
%%        \State \textbf{return} $b, r, h: (\vv{b_c}, \vv{r_c}), (\vv{b_{c1}, \vv{r_{c1}}}), (\vv{b_{c2}, \vv{r_{c2}}})$
%        \State \textbf{return} \Call{Identify}{$b, R$} \Comment No confidence check.
%        \EndIf
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

The \textit{Interior Angle} strategy is composed of Liebe's feature set (two interstar angles, an interior angle), Liebe's $\imagesubset$ image subset decision, and a permutation store for identification.
Given a set of points from the image $\imageset$, Liebe approaches the image subset $b$ selection problem by choosing the first image point $b_c \seq \imageset[1]$ and two of the nearest image points $b_1, b_2$ to $\imageset[1]$ to compose $b \seq \{ b_c, b_1, b_2 \}$.
To select another $b$ set is to choose $b_c \seq \imageset[2]$ and the two nearest stars to $\imageset[2]$.
Liebe's image subset decision iterates through $\imageset$ once, not exploring all possible combinations like the Angle strategy~\cite{liebe:starTrackersAttitudeDetermination}.
With an image subset selected, we can now search for $r$ sets.
There are three features associated with this strategy: (a) the angular separation between the first image point and the second, (b) the angular separation between first image point and the third, and (c) the angular separation between the second and third image points with the first point as the vertex.
Let $\texttt{REF}_\texttt{INT}$ define a relation holding tuples of all \emph{permutations} of three $\texttt{REF}$ identifiers, pairwise indexed by all the previously mentioned features for the corresponding $r$ set.
The Interior Angle method performs a three-dimensional range search for all $r$ sets such that features of $r$ are close to the features of $b$~\cite{bratt:analysisStarIdentification}.
If our database search yields a single $r$ set, we proceed to the last step: map determination.
RezaToloei's implementation sacrifices storage to avoid performing an optimal map determination procedure (e.g.\ the direct-match test) by storing all permutations of $\texttt{REF}$ instead of combinations like the Angle strategy~\cite{toloei:compositeIdentification}.
When this permutation store is used in conjunction with an asymmetry rule, ``feature (a) must be less than feature (b)'', we store the mapping of $r$ as well~\cite{anderson:autonomousStarSensing}.
Thus, to determine a map here is to use the pairing: $\{(b_c, r_c), (b_1, r_1), (b_2, r_2)\}$.


%A new central point selection does not involve generating permutations like the Angle strategy, rather it involves iterating through $\imageset$ in a sequential manner.
%The two closest points the image to the central points are selected next, which compose stars $\imagesubset[1]$ and $\imagesubset[2]$ repsectively~\cite{liebe:starTrackersAttitudeDetermination}.
%
%The candidate retrieval step searches the $\intdatabase$ set for trios such that the features of the database trios are close to the same features of the image subset~\cite{bratt:analysisStarIdentification}.
%Unlike the Angle strategy's $\angdatabase$ set, $\intdatabase$ is defined to be all \textit{permutations} of size $d\seq 3$ rather than combinations of size $d\seq 2$.
%These features are defined as the angular separation between the first closest point and the central point ($\theta\left(\vv{\imagesubset[1]}, \vv{\imagesubset[2]}\right)$ vs. $ \theta\left(\vv{\candidateset[1]}, \vv{\candidateset[2]}\right)$), the angular separation between the second closest point and the central point ($\theta\left(\vv{\imagesubset[1]}, \vv{\imagesubset[3]}\right) $ vs. $\theta\left(\vv{\candidateset[1]}, \vv{\candidateset[3]}\right)$), and the angular separation between the two closest points with the central point as the origin instead of the Earth or focal point of the lens ($\phi(\imagesubset) $ vs. $ \phi(\candidateset)$).
%To obtain $\databasesubset$, the predicate $P_{\theta, \phi}(\candidateset, \imageset)$ is used to filter $\intdatabase$:

%\begin{equation}
%    \begin{aligned}
%        P_{\theta, \phi} (\candidateset, \imagesubset): \left\lvert \theta(\vv{\imagesubset[1]}, \vv{\imagesubset[2]}) - \theta(\vv{\candidateset[1]}, \vv{\candidateset[2]})\right\rvert
%        &< \epsilon_{\theta} \ \land \\ \left\lvert \theta(\vv{\imagesubset[1]}, \vv{\imagesubset[3]}) - \theta(\vv{\candidateset[1]}, 
%        \vv{\candidateset[3]})\right\rvert &< \epsilon_{\theta} \ \land \\ \left\lvert \phi(\imagesubset) - \phi(\candidateset)\right\rvert &<  
%        \epsilon_\phi \ \land \\\theta(\vv{\candidateset[1]}, \vv{\candidateset[2]}) &< \theta(\vv{\candidateset[1]}, \vv{\candidateset[3]})
%    \end{aligned}
%\end{equation}
%where $\epsilon_{\theta}$ and $\epsilon_{\phi}$ represent the uncertainty between the $\theta$ and $\phi$ computations with the sensor measurements and the same $\theta$ and $\phi$ computations with points defined in the database.

%The original literature states that this should be repeated for all $b$ sets.
%Given that complete identification of $I$ is not the goal, this method has been adjusted to query with one $b$ at a time.
%After finding some $\databasesubset$ that meets the same $\databasesubset$ criterion as the Angle strategy, the function:
%\begin{equation}
%    h \mid h(\imagesubset[1]) = \candidateset[1], \ h(\imagesubset[2]) = \candidateset[2], \ h(\imagesubset[3]) = \candidateset[3]
%\end{equation}
%is constructed and returned.
%RezaToloei's implementation imposes the last term in predicate $P_{\theta, \phi}(\candidateset, \imagesubset)$ at candidate retrieval time~\cite{toloei:compositeIdentification}, borrowing from Anderson (according to Spratling) by searching all permutations instead of combinations to remove the need for an optimal map determination procedure~\cite{anderson:autonomousStarSensing}.
%It would be remiss to not point out that storing permutations instead of combinations results in a larger database to query, which begs the question, ``Does this sacrifice in space reduce the overall runtime?''.
%Storing permutations is a more space-intensive solution though, which will result in a longer candidate retrieval time when compared to another $d\seq 3$ strategy like the Spherical Triangle.
%Storing permutations does increase the storage required for $\bar{K^3}$ though, which begs the question, ``Does this extra space aid in accuracy or runtime?''.

%The star trios in the catalog star candidates represent potential catalog maps for the image star trio $(b_i, b_j,
%b_c)$.
%Liebe's original method states that this process should be repeated for all stars in the image, meaning that all
%stars will be the central star at one point
%By the end, each star in the image will have accrued a set of possible catalog matches $Y$.
%The complete $I \rightarrow R$ map is found by picking the most frequent catalog star appearing in each $Y$
%set~\cite{liebe:starTrackersAttitudeDetermination,bratt:analysisStarIdentification}.
%
%To more closely follow the generic star identification flow, we modified the Interior Angle method to not store $Y$,
%requiring that only one central star choice is needed to acquire a total match.
%If a confident match is not found by the first central star, then the search process will be repeated until such a
%match is found.

%The running time of this algorithm $T_\texttt{INT}$ is depicted below, again described in terms of the number of queries and the number of entries in $\intdatabase$:
%\begin{equation}\label{eq:dotComplexity}
%    T_\texttt{INT} = O\left( n \cdot \log(m_\texttt{INT}) \right)
%\end{equation}
%where $m_\texttt{INT}$ is the cardinality of $\intdatabase$.

%This entire method is described in~\autoref{algorithm:interiorAngleIdentification}.

%\subsection{Spherical Triangle Strategy (SPH)}\label{subsec:sphericalTriangleMethod}
%\begin{algorithm}
%    \caption{Triangle Identification Strategy} \label{algorithm:triangleIdentification}
%    \begin{algorithmic}[1]
%%        \Function{PartialMatch}{$\texttt{REF}_1, R_2$}
%%        \State \textbf{return} 
%%%        \State $\texttt{REF}_\texttt{MATCHES} \gets \emptyset$
%%%        \ForAll {$\texttt{REF}_1 \in R_1$}
%%%        \If {a $\texttt{REF}_2 \in R_2$ exists s.t. $\texttt{REF}_1$ and $\texttt{REF}_2$ share two stars}
%%%        \State $\texttt{REF}_{\texttt{MATCHES}} \gets R_\texttt{MATCHES} \cup \{r_1\}$
%%%        \EndIf
%%%        \EndFor
%%%        \State \textbf{return} $\texttt{REF}_\texttt{MATCHES}$
%%        \EndFunction
%%        \\
%        \Function{Pivot}{$\vv{b}, R, \texttt{TRI\_DB}$}
%        \State $\texttt{REF}_\texttt{THIS\_PIVOT} \gets \set{ r \mid r \in \texttt{TRI\_DB}
%        \land P_{a, \tau}(r, b) }$
%        \State $\texttt{REF}_\texttt{MATCHES} \gets $ \parbox[t]{0.7\textwidth}{\raggedright all $\texttt{REF}_1 \in R_\texttt{THIS\_PIVOT}$ s.t. $\texttt{REF}_1$ shares 2 stars with \newline some $\texttt{REF}_2 \in R$}
%        \If{$\abs{R_\texttt{MATCHES}} \leq 1$}
%        \State \textbf{return} $\texttt{REF}_\texttt{MATCHES}$ 
%        \Else \Comment Recurse until solution / exhaust all other stars.
%        \State $b \gets \left( b[1], b[2], \text{an unused point in this pivot} \right)$
%        \State \textbf{return} \Call{Pivot}{$b, R_\texttt{MATCHES}, \texttt{TRI\_DB}$}
%        \EndIf
%        \EndFunction
%        \\
%    	\Function{RetrieveCandidates}{$b, \texttt{TRI\_DB}$}
%    	\State $R \gets \set{ r \mid r \in \texttt{TRI\_DB} \land P_{a, \tau}(r, b) }$
%    	\If{$\abs{R} \neq 1$}
%    	\State \textbf{return} \Call{Pivot}{$b, R, \texttt{TRI\_DB}$}
%    	\Else
%    	\State \textbf{return} $R$
%    	\EndIf
%    	\EndFunction
%        \\
%        \Function{Identify}{$b, R, \imageset, \databaseset$}
%        \State $r \gets R[1]$ \Comment Select our candidate.
%        \State \textbf{return} \Call{DMT}{$\imagesubset, r, \imageset, \databaseset$}
%        \EndFunction
%        \\
%        \Procedure{Query}{$\imageset, \texttt{TRI\_DB}, \databaseset$} 
%        \LineComment $\texttt{TRI\_DB} \in \set{\plndatabase, \sphdatabase}$, algorithm used for both.
%        \For{$i \gets 1 \text{\textbf{ to }} n$}  
%        \For{$j \gets i + 1 \text{\textbf{ to }} n - 1$}
%        \For{$k \gets j + 1\text{\textbf{ to }} n - 2$}
%        \LineComment Select $d=3$ image points.
%        \State $b \gets \left(\vv{\imageset[i]}, \vv{\imageset[j]}, \vv{\imageset[k]}\right)$ 
%        \State $R \gets $ \Call{RetrieveCandidates}{$b, \texttt{TRI\_DB}$}
%        \If{$\abs{R} = 1$} \Comment Verify cardinality.
%        \State $h \gets $ \Call{Identify}{$b, R, \imageset, \databaseset$}
%        \invalidBijection \Comment Confidence check.
%        \State \textbf{return} $b, h$
%        \EndIf
%        \EndIf
%        \EndFor
%        \EndFor
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

The \textit{Spherical Triangle} strategy is composed of Cole and Crassidus's spherical area and moment features, a naive $b$ image subset decision, Cole and Crassidus's $r$ selection process, and a direct-match test to create the image to database function.
Given a set of points from the image $\imageset$, our query starts by selecting three distinct points to represent the $b$ set.
Similar to the Angle strategy, we naively choose $b$ sets by fixing $b_1$ for $n^2$ image subset selection, fixing $b_2$ for $n$ image subset selections, and constantly changing $b_3$ for every new $b$ choice.
Now having an image subset selected, we follow Cole and Crassidus's $r$ ``pivoting`` selection process.
Let $\texttt{REF}_\texttt{SPH}$ define a relation holding tuples of all combinations of three \texttt{REF} identifiers, pairwise indexed by the spherical area and moment between all three \texttt{REF} points.
We proceed by performing a two-dimensional range search for all $r$ sets such that the spherical area and moment of $b$ is close to the spherical area and moment of $r$.
If our database search does not yield a single $r$ set, we perform another range search for $R^\star$ with a new image subset $b^\star$ that differs from our original $b$ by only one point.
The results of the secondary search $R^\star$ are then used to filter the initial set by removing all sets in $R$ that don't share two points with $R^\star$.
This ``pivot'' is repeated to filter the original $R$ further until there are no more distinct $b^\star$ sets to form~\cite{coleAndCrassidis:sphericalTriangleMethod}.
The Spherical Triangle method trades a higher worst-case running time (iterating at most $n^4$ times) for the ability to use utilize the information of multiple database searches together.
Once a sole $r$ set is obtained, we perform a direct match test to either obtain a map or choose another $b$ set and repeat the process altogether.

%Given a set of query points from the image $\imageset$, $d \seq 3$ points are selected to obtain the $b$ set in the same straightforward manner as the Angle strategy.
%%Again, the $b$ selection is not specified here so we assume the naive approach with $C(n, 3)$ combinations.
%For $\binom{\imageset}{3}$ combinations the point $\vv{b[1]}$ is fixed in $b$ for $n^2$ image subset selections, the point $\vv{b[2]}$ is fixed for $n$ selections, and the last point $\vv{b[3]}$ is constantly changed for every new $b$ choice.
%
%The Spherical Triangle strategy utilizes the $\sphdatabase$, which consists of all possible combinations of trios in $\databaseset$.
%The candidate retrieval step searches the $\sphdatabase$ set for trios such that the spherical area and moment of the database trios are close to the spherical area and moment of the image subset~\cite{coleAndCrassidis:sphericalTriangleMethod}.
%For the image subset, the spherical area and moment are represented as $a(b)$ and $\tau(b)$ respectively.
%For the database candidate set, these same features are represented as $a(r)$ and $\tau(r)$.
%To obtain $R$, the predicate $P_{a, \tau}(r, b)$ is used to filter $\sphdatabase$:
%\begin{equation}
%    \begin{aligned}
%        P_{a, \tau}(r, b) : \abs{ a(r) - a(b)} &< \epsilon_{a}
%        \ \land \\ \abs{\tau(r) - \tau(b)} &< \epsilon_{\tau}
%    \end{aligned}
%\end{equation}
%where $\epsilon_{a}$ and $\epsilon{\tau}$ represent the uncertainty between the $a$ and $\tau$ computations with the sensor measurements and the same $a$ and $\tau$ computations with point defined in the database.
%
%Unlike the previous two strategies, the $R$ criterion of $|R| \seq 1$ not being met does not lead to an immediate new selection of $b$.
%Instead, the candidate set itself is reduced by \textit{pivoting} until the criterion is met or pivots can no longer be performed.
%The pivoting procedure starts by searching the database again for a second set of database candidate sets with a different image subset.
%In this new subset, the first two points are held constant while the third point is swapped with another in $\imageset$ that was not already used in this specific pivot.
%All trios in the initial search that do not match a trio in the second search by \textit{two points} (a partial match) are removed from the initial search candidate set~\cite{coleAndCrassidis:sphericalTriangleMethod}.
%A pivot uses at most $n - 3$ additional database accesses, but prevents wasting an $R$ set that may contain the correct $r$ set for the given $b$.

%\begin{algorithm}
%    \caption{Pyramid Identification Strategy} \label{algorithm:pyramidIdentification}
%    \begin{algorithmic}[1]
%%        \Function{Flatten}{$Q_1, Q_2$}
%%        \State \textbf{return} the union of all \emph{stars} in $Q_1$ and $Q_2$
%%        \LineComment Flatten $T_1, T_2$ from set of sets to a set.
%%        \State $\bar{T_1} \gets \emptyset, \bar{T_2} \gets \emptyset$
%%        \ForAll{$i \in \set{1, 2}$}
%%        \ForAll{$\vv{t} \in T_i$}
%%        \State $\bar{T_i} \gets \bar{T_i} \cup \set{ \vv{t_1}, \vv{t_2} }$
%%        \EndFor
%%        \EndFor
%%        \State \textbf{return} $\bar{T_1} \cap \bar{T_2}$
%%        \EndFunction
%%        \\
%        \Function{FindTriplet}{$B, \pyrdatabase$}
%        \State $Q[1] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, B[1]\right) }$
%        \State $Q[2] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, B[2]\right) }$
%        \State $Q[3] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, B[3]\right) }$
%        \State \textbf{return} $Q$
%        \EndFunction
%        \\
%        \Function {RetrieveCandidates}{$b, \pyrdatabase$}
%        \State $B \gets \left(\set{b[1], b[2]}, \set{b[1], b[3]}, \set{b[2], b[3]}\right)$
%        \State $Q \gets $ \Call{FindTriplet}{$B, \pyrdatabase$}
%%        \State $Q[1] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, \set{b[1], b[2]}\right) }$
%%        \State $Q[2] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, \set{b[1], b[3]}\right) }$
%%        \State $Q[3] \gets \set{ r \mid r \in \pyrdatabase \land P_\theta \left(r, \set{b[2], b[3]}\right) }$
%        \State \textbf{return} \parbox[t]{0.8\textwidth}{\raggedright all unique 3-permutations of all \emph{stars} in order \newline of $\{Q[1], Q[2]\}$, $\{Q[1], Q[3]\}$, $\{Q[2], Q[3]\}$}
%%        \State \textbf{return} \parbox[t]{0.8\textwidth}{\raggedright all unique permutations of \Call{Flatten}{$Q[1], Q[2]$}, \newline \Call{Flatten}{$Q[1], Q[3]$}, \Call{Flatten}{$Q[2], Q[3]$}}
%%        \State $R \gets \emptyset$
%%        \ForAll{$t_i \in$ \Call{FC}{$T_{ij}, T_{ik}$}}
%%        \ForAll{$t_j \in$ \Call{FC}{$T_{ij}, T_{jk}$}}
%%        \ForAll{$t_k \in$ \Call{FC}{$T_{ik}, T_{jk}$}}
%%        \State $R \gets R \cup \set{ \left(\vv{t_i}, \vv{t_j}, \vv{t_k}\right) }$
%%        \EndFor
%%        \EndFor
%%        \EndFor
%%        \State \textbf{return} $R$ \Comment Return all permutations from $T$ sets.
%        \EndFunction
%        \\
%        \Function{ConfidenceCheck}{$\imageset, b, \pyrdatabase$}
%        \State $\beta \gets $ some point in $\imageset$ where $\beta \notin b$
%        \State $B \gets \left(\set{b[1], \beta}, \set{b[2], \beta}, \set{b[3], \beta}\right)$
%        \State $Q \gets $ \Call{FindTriplet}{$B, \pyrdatabase$}
%        \State \textbf{return} \parbox[t]{0.8\textwidth}{true if there is the only one sole common star  \newline in all $Q$ sets, false otherwise}
%%        \State \textbf{return} $\abs{\Call{Flatten}{Q[1], Q[3]} - \Call{Flatten}{Q[2], Q[3]}} = 1$
%        \EndFunction
%        \\
%        \Function{Identify}{$b, R, \imageset, \pyrdatabase$}
%        \State \textbf{return} $\imagesubset, \solutionmap \mid \solutionmap(\imagesubset[1]) = \candidateset[1], \ \solutionmap(\imagesubset[2]) = \candidateset[2], \ \solutionmap(\imagesubset[3]) = \candidateset[3]$
%        \EndFunction
%        \\
%        \Procedure{Query}{$\imageset, \pyrdatabase$}
%%        \LineComment Iterate through $\binom{\imageset}{3}$ while avoiding false points.
%        \For{$dj \gets 1 \text{\textbf{ to }} n - 2$} \label{algline:pyramidI}
%        \For{$dk \gets 1 \text{\textbf{ to }} n - 1 - dj$} \label{algline:pyramidJ}
%        \For{$i \gets 1 \text{\textbf{ to }} n - dj - dk$} \label{algline:pyramidK}
%        \State $j \gets i + dj$ \Comment Select $d\seq 3$ image points.
%        \State $k \gets j + dk$ 
%        \State $b \gets \left(\vv{\imageset[i]}, \vv{\imageset[j]}, \vv{\imageset[k]}\right)$
%        \State $R \gets $ \Call{RetrieveCandidates}{$b, \pyrdatabase$}
%        \If{$\abs{R} = 1$} \Comment Verify cardinality.
%		\If{\Call{ConfidenceCheck}{$\imageset, b, \pyrdatabase$}}
%%        \State $Q \gets $ \Call{FindTriplet}{}
%%        \State $(T_{ij}, T_{ik}, T_{jk}) \gets$ \Call{FindT}{$\set{ \vv{b_i}, \vv{\beta} }, \set{ \vv{b_j},
%%        \vv{\beta} },$
%%        \State \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ $\set{ \vv{b_k}, \vv{\beta} }, K^2$}
%        
%%        \State \textbf{return} $\imagesubset, \solutionmap \mid $ \parbox[h]{0.5\linewidth}{\raggedright $\solutionmap(\imagesubset[1]) = \candidateset[1], \ \solutionmap(\imagesubset[2]) = \candidateset[2], \newline \ \solutionmap(\imagesubset[3]) = \candidateset[3]$}
%        \State \textbf{return} \Call{Identify}{$b, R$} 
%        %        \State \textbf{return} $b, r, h: \vv{b_1} \mapsto \vv{r_1}, \vv{b_2} \mapsto \vv{r_2},$
%        \EndIf
%        \EndIf
%        \EndFor
%        \EndFor
%        \EndFor
%        \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

%\begin{subequations}
%    The \Call{DMT}{} process is used to complete the constellation query here.
%    Given an image trio and a database trio, the following map is proposed:
%    \begin{equation}
%        h_1 \mid h_1(b[1]) = r[1], \ h_1(b[2]) = r[2], \ h_1(b[3]) = r[3]
%    \end{equation} \label{eq:trianglePossibleMaps}
%    The TRIAD method only uses two vector observations from each coordinate system, meaning that the $(b[3], r[3])$ pairing is disregarded as the first rotation $A_1$ is computed.
%    This process is repeated for all 5 other possible maps to get $A_2, A_3, \dots, A_6$.
%    \begin{align}
%        h_2 &\mid h_2(b[1]) = r[1], \ h_2(b[2]) = r[3], \ h_2(b[3]) = r[2] \\
%        h_3 &\mid h_3(b[1]) = r[2], \ h_3(b[2]) = r[1], \ h_3(b[3]) = r[3] \\
%        h_4 &\mid h_4(b[1]) = r[2], \ h_4(b[2]) = r[3], \ h_4(b[3]) = r[1] \\
%        h_5 &\mid h_5(b[1]) = r[3], \ h_5(b[2]) = r[1], \ h_5(b[3]) = r[2] \\
%        h_6 &\mid h_6(b[1]) = r[3], \ h_6(b[2]) = r[2], \ h_6(b[3]) = r[1]
%    \end{align}
%\end{subequations}
%For all six attitudes, the mapping yielding the most aligned points is returned.

%The running time of this algorithm $T_\texttt{SPH}$ is depicted in~\autoref{eq:sphereComplexity}, in terms of the number of queries and the number of entries in the $\sphdatabase$ database.
%At most, this requires $2n^4$ database accesses: $n^3$ for each combination of trios in $\imageset$, $n - 3$ potential database accesses for each pivot, and an additional $n^4$ queries with each \Call{DMT}{} call.
%\begin{equation}\label{eq:sphereComplexity}
%    T_{sphere} = \bigO\left( n^4 \cdot \log (m_\texttt{SPH}) \right)
%\end{equation}
%where $m_\texttt{SPH}$ is the cardinality of $\sphdatabase$.

%This entire method is described in~\autoref{algorithm:triangleIdentification}.

The \textit{Planar Triangle} strategy is identical to their Spherical Triangle strategy, with the exception that each image trio is represented as a planar triangle instead of a spherical one.
This results in the computation of a planar area and moment as opposed to a spherical area and moment.

%\subsection{Planar Triangle Strategy (PLN)}\label{subsec:coleAndCrassidus'sPlanarTriangleMethod}

%\subsection{Pyramid Strategy (PYR)}\label{subsec:pyramidMethod}
The \textit{Pyramid} strategy is composed of Mortari's $b$ image subset decision, a custom voting based identification process for trios, and a voting based confidence check.
Given a set of points from the image $\imageset$, Motari selects three points $b_1, b_2, b_3$ in a such a way to avoid the persistence of misleading points for more than a few combinations
~\cite{mortari:pyramidIdentification}.
What follows is a Tichy-inspired voting-based process which utilizes the relation $\texttt{REF}_\texttt{ANG}$.
Per image subset, three of the database range searches used in the Angle strategy are performed for the pairings $(b_1, b_2)$, $(b_1, b_3)$, $(b_2, b_3)$ to get $R_{1,2}$, $R_{1,3}$, $R_{2,3}$.
To determine points for $b_1$ (denoted as the set $R_1$) is to take the intersection between the set of points in $R_{1,2}$ and the set of points in $R_{1,3}$.
Once repeated for $R_2$ (between $R_{1,2}, R_{2,3}$) and $R_3$ (between $R_{1,3}$, $R_{2,3}$), if all $R_1$, $R_2$, $R_3$ yield sole results, we construct the map $\{ (b_1, R_1[1]), (b_2, R_2[1]), (b_3, R_3[1])\}$~\cite{tichy:preliminaryTestsCommericalImagers}.
Similar to the Interior Angle method, an optimal map determination procedure is not required because the map is implicitly formed to get $r$.
To establish confidence in this map, another voting strategy is used which repeats a process similar to obtain $r$ with the inclusion of an additional star $b_4$ from $\imageset$.
Only if there exists a sole result associated with $b_4$ do we return the map.
Otherwise, we choose another $b$ set and repeat the process.

%Given a set of query points from the image $\imageset$, $d \seq 3$ points are selected to obtain the $b$ set.
%The selection order is governed by lines~\ref{algline:pyramidI},~\ref{algline:pyramidJ}, and~\ref{algline:pyramidK} in~\autoref{algorithm:pyramidIdentification}.
%As opposed to the selection order of the Angle and triangle strategies, the $\vv{b[1]}$ point in $b$ is no longer fixed for $n$ or $n^2$ image subset selections.
%This is meant to avoid the persistence of misleading points for more than a few combinations
%~\cite{mortari:pyramidIdentification}.
%An example sequence of trios is depicted below for $n \seq 5$ points.
%\begin{equation}
%    \binom{\imageset}{3} = 
%    \begin{aligned}
%    	( &\set{\vv{\imageset[1]}, \vv{\imageset[2]}, \vv{\imageset[3]}}, \\
%    	&\set{\vv{\imageset[2]}, \vv{\imageset[3]}, \vv{\imageset[4]}}, \\
%        &\set{\vv{\imageset[3]}, \vv{\imageset[4]}, \vv{\imageset[5]}}, \\
%        &\set{\vv{\imageset[1]}, \vv{\imageset[2]}, \vv{\imageset[4]} }\ldots )
%    \end{aligned}
%\end{equation}

%\begin{subequations}
%%The literature states that a unique and identifiable trio is to be found after the query step using $\theta$,
%%but does not specify how nor is source code provided.
%The approach developed here was inspired by the two point voting algorithm, which accumulates "votes" for some point by determining the angle between the same point and two other points~\cite{tichy:preliminaryTestsCommericalImagers}.
%We start by retrieving pairs from $\pyrdatabase$, an identical set to $\angdatabase$, such that the angular separations of the database pairs are close to the angular separation of the image pair $\set{\vv{b[1]}, \vv{b[2]}}$.
%This is repeated for the other two permutations $\set{\vv{b[1]}, \vv{b[3]}}$ and $\set{ b[2], \vv{b[3]} }$ to obtain the sets $Q[1], Q[2]$ and $Q[3]$ respectively.
%Candidates for each image point are then found by taking the difference of the stars in two $Q$ sets.
%For the sets of pairs $Q[1], Q[2]$ found by searching $\pyrdatabase$ with $P_\theta$ and $\set{\vv{b[1]}, \vv{b[2]}}, \set{\vv{b[1]}, \vv{b[3]}}$, the common point between each $b$ set is $\vv{b[1]}$.
%An example of finding database candidates for $b[1]$ with this method is given below:
%\begin{equation}
%    \begin{aligned}
%        Q[1] \gets& \set{ \set{\vv{\databaseset_{1123}}, \vv{\databaseset_{9001}}}, \set{\vv{\databaseset_{8234}}, \vv{\databaseset_{33}}} } \\
%        Q[2] \gets& \set{ \set{\vv{\databaseset_{612}}, \vv{\databaseset_{1123}}}, \set{\vv{\databaseset_{33}}, \vv{\databaseset_{345}}} } 
%    \end{aligned}
%\end{equation}
%\begin{equation}  
%	\text{database candidates for } b[1] = \set{\databaseset_{1123}, \databaseset_{33}} 
%\end{equation}
%\end{subequations}
%$R$ is found by repeating the process above for $b[2]$ and $b[3]$, and generating all possible permutations.
%This is depicted in the \Call{RetrieveCandidates}{} function in~\autoref{algorithm:pyramidIdentification}.
%
%After finding some $R$ where $\abs{R} = 1$, a confidence check step is performed.
%A different point from the image $\vv{\beta}$ is selected and the candidate retrieval step is performed for each distinct trio combination of $b$ and $\vv{\beta}$.
%Confidence is established if and only if there exists one common star across all $Q$ sets.
%Only then do we return a mapping $h(b_1) = r_1 \ h(b_2) = r_2 \ h(b_3) = r_3$.
%Like the Interior Angle strategy, an optimal map determination procedure is not required to find $h$.
%Instead, each individual point is identified at candidate retrieval time.
%
%The running time of this algorithm $T_\texttt{PYR}$ is depicted below in terms of the number of queries and the number of elements in $\pyrdatabase$.
%At most, this requires $6n^3$ database accesses: $3n^3$ accesses for each $Q$ retrieval with an additional $3n^3$ accesses for each confidence checking step.
%\begin{equation}
%    T_{\texttt{PYR}} = \bigO \left( n^3 \cdot \log( m_\texttt{PYR} ) \right)
%\end{equation}
%where $m_\texttt{PYR}$ is the cardinality the $\pyrdatabase$.

%This entire method is specified in~\autoref{algorithm:pyramidIdentification}.

%\begin{algorithm}
%    \caption{Composite Pyramid Identification Method}\label{algorithm:compositePyramid}
%    \begin{algorithmic}[1]
%        \Function{Identify}{$I, K^3$}
%        \LineComment Iterate through $C(n, 3)$ while avoiding false stars.
%        \For{$dj \gets 1 \text{\textbf{ to }} n - 2$}
%        \For{$dk \gets 1 \text{\textbf{ to }} n - 1 - dj$}
%        \For{$i \gets 1 \text{\textbf{ to }} n - dj - dk$}
%        \State $j \gets i + dj$, $k \gets j + dk$
%        \State $b \gets (\vv{b_i}, \vv{b_j}, \vv{b_k})$
%        \State $R \gets \set{ r \mid r \in K^3 \land P{a, \tau}(r, b) }$
%        \If{$\lvert R \rvert = 1$}
%        \LineComment Verification step below.
%        \State $\beta \gets $ single star in $I$ where $\beta \notin b$
%        \State $T_{12\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau}(r, \set{\vv{b_1}, \vv{b_2}, \vv{\beta}})}$
%        \State $T_{13\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau}(r, \set{\vv{b_1}, \vv{b_3}, \vv{\beta}})}$
%        \State $T_{23\beta} \gets \set{ r \mid r \in K^3 \land P_{a, \tau} (r, \set{\vv{b_2}, \vv{b_3}, \vv{\beta}})}$
%        \State $T_\beta \gets $ \Call{FC}{$T_{12\beta}, T_{13\beta}$} $\cap$ \Call{FC}{$T_{j13\beta}, T_{23\beta}$}
%        \If{$\abs{T_\beta} = 1$}
%        \State $h \gets$ \Call{DMT}{$b, R_1, I$}
%        \invalidBijection
%        \State \textbf{return} $h$
%        \EndIf
%        \EndIf
%        \EndIf
%        \EndFor
%        \EndFor
%        \EndFor
%        \EndFunction
%    \end{algorithmic}
%\end{algorithm}

%\subsection{Composite Pyramid Strategy (COM)}\label{subsec:compositePyramidMethod}
The \textit{Composite Pyramid} strategy is composed of Mortari's $b$ image subset decision, Cole and Crassidus's spherical area and moment features, and a voting based confidence check.
This method can be thought of as a combination of the Planar Triangle strategy and the Pyramid strategy, borrowing the feature, database range search, and optimal map determination strategy of the former while borrowing the image subset decision and confidence check of the latter.

%Given a set of query points from the image $\imageset$, $d \seq 3$ points are selected in same manner as the Pyramid strategy to obtain the $b$ set.
%From here, the process to obtain the $R$ set is the same as the triangle strategies: use $P_{a, \tau}(r, b)$ and $b$ to select all candidates from $\comdatabase$.
%Note that $\comdatabase$ is equivalent to $\sphdatabase$ here.
%If the current $R$ set meets the same $\abs{R} \seq 1$ criterion, then a similar confidence check to the Pyramid strategy is performed with the Planar Triangle features.
%Once this test has passed, the \Call{DMT}{} method is used to construct the function $h$ to potentially return.
%The Pyramid strategy did not need this call as an implicit mapping was formed through its candidate retrieval process.
%
%The running time of this algorithm $T_{\texttt{COM}}$ is depicted below in terms of number of queries and the number of elements in $\comdatabase$.
%At most, this requires $5n^3$ database accesses: $n^3$ for each $Q$ retrieval, an additional $3n^3$ accesses for each confidence check, and an additional $n^3$ accesses for each \Call{DMT}{} call.
%\begin{equation}
%    T_{\texttt{COM}} = \bigO (n^3 \cdot \log(m_\texttt{COM}))
%\end{equation}
%where $m_\texttt{COM}$ is the cardinality of $\comdatabase$.

%This entire method is specified in~\autoref{algorithm:compositePyramid}.

%\begin{table*}[ht]
%    \centering{
%    \caption{
%    Overview table of the different identification methods.
%    Each method's image features, reduction process, identification process is displayed.
%    } \label{tab:identificationMethodOverview}
%    \input{include/floats/summary-table}
%    }
%\end{table*}
