/// @file astrometry-net.h
/// @author Glenn Galvizo
///
/// Header file for AstrometryNet class, which matches a set of body vectors (stars) to their inertial counter-parts
/// in the database.

#ifndef HOKU_ASTROMETRY_NET_H
#define HOKU_ASTROMETRY_NET_H

#include "benchmark/benchmark.h"
#include "storage/chomp.h"
#include "storage/kd-node.h"
#include "math/asterism.h"
#include <iostream>

/// The astrometry-net class is an implementation of Lang, Hoggs, (et al.)'s Blind Astrometric Calibration Process.
/// This is one of the five star identification procedures being tested.
///
/// @example
/// @code{.cpp}
/// // Populate a table named "ASTRO20" in Nibble.db of distinct asterisms of stars whose angle of separation is
/// // less than 20 degrees of each. The entries stored are the HR numbers and the four hash codes generated by quad.
/// AstrometryNet::generate_astro_table(20, "ASTRO20");
///
/// /* The snippet above should only be run ONCE. The snippet below is run with every different test. */
///
/// // Find all stars around a random star within 7.5 degrees of it. Rotate all stars by same random rotation.
/// Benchmark b(15, Star::chance(), Rotation::chance());
///
/// // Append 2 extra stars to the data-set above.
/// b.add_extra_light(2);
///
/// Astro::Parameters p;
/// // The minimum number of stars to match the body and inertial is now 7.
/// p.match_minimum = 7;
///
/// // Print all matches (the key here is the 'identify' method).
/// for (const Star &s : Astro(b, p).identify()) {
///     printf("%s", s.str().c_str());
/// }
/// @endcode
class AstrometryNet {
  private:
    friend class TestAstrometryNet;
  
  public:
    /// Defines the query, match, and utility operators, user can tweak for custom performance.
    struct Parameters {
        double query_sigma = 0.00000000001; ///< A hash query must be within 3 * query_sigma of a given search.
        unsigned int query_expected = 10; ///< Expected number of stars to be found with query. Better to overshoot.
        double match_sigma = 0.00001; ///< Resultant of inertial->body rotation must within 3 * match_sigma of *a* body.
        double kd_tree_w = 1000; ///< Projection width of the KD-trees.
        unsigned int nearby_expected = 100; ///< Expected number of nearby stars to be found. Better to overshoot.
        double k_alignment_accept = 60; ///< Value of K to accept a given alignment.
        double u_tp = 1.0; ///< Utility of a true positive match. Used in Bayesian decision process.
        double u_fp = -1.0; ///< Utility of a false positive match. Used in Bayesian decision process.
        double u_tn = 1.0; ///< Utility of a true negative match. Used in Bayesian decision process.
        double u_fn = -1.0; ///< Utility of a false negative match. Used in Bayesian decision process.
        std::string hash_name = "ASTRO_H20"; ///< Name of the hash table created with 'generate_astro_table'.
        std::string center_name = "ASTRO_C20"; ///< Name of the centers table created with 'generate_astro_table'.
    };
    
    /// User should **NOT** be creating instances of AstrometryNet. Instead, use the static 'identify' function.
    AstrometryNet () = delete;
  
  public:
    static Star::list identify (const Benchmark &, const Parameters &);
    
    static int generate_hash_table (const int, const int, const std::string &);
    static int generate_center_table (const std::string &, const std::string &);
  
  private:
    /// Alias for a list of Harvard Revised numbers (STL vector of doubles).
    using hr_list = std::vector<int>;
    
    /// Alias for a quad of Harvard Revised numbers (4-element STL array of integers).
    using hr_quad = std::array<int, 4>;
    
    /// Alias for a list of Harvard Revised number quads (STL vector of 4-element arrays of integers).
    using hr_list_quad = std::vector<std::array<int, 4>>;
    
    /// Alias for a quad of index numbers for the input star list (4-element STL array of doubles).
    using index_quad = std::array<int, 4>;
    
    /// Alias for an 2-element set of models (2-element STL array of Star lists).
    using models = std::array<Star::list, 2>;
  
  private:
    AstrometryNet (const Benchmark &, const Parameters &);
    
    static int insert_astro_h (Nibble &, std::vector<int> &, const double, const hr_quad &, const double);
    
    hr_quad query_for_asterism (const hr_quad &);
    
    Rotation propose_alignment (const index_quad &, const hr_quad &);
    models classify_matches (const hr_quad &, const Rotation &);
    
    hr_list_quad nearby_asterisms (const hr_quad &);
    unsigned int compare_alignments (const models &, const models &);
  
  private:
    /// The star set we are working with. The HR values are all set to 0 here.
    Star::list input;
    
    /// The centers of each asterism. Used to reference the KD tree.
    Star::list astro_stars;
    
    /// All stars in 'input' are fov degrees from the focus.
    double fov;
    
    /// Current working parameters.
    Parameters parameters;
    
    /// Chomp instance. This is where multi-threading 'might' fail, with repeated access to database.
    Chomp ch;
    
    /// Kd-tree root. Used for finding nearby stars.
    std::shared_ptr<KdNode> star_root;
    
    /// Another Kd-tree root. Used for finding nearby **asterisms**.
    std::shared_ptr<KdNode> astro_root;
    
    /// Current proposed alignment.
    Rotation proposed;
};

/// Alias for the AstrometryNet class. 'Astro' distinguishes the process I am testing here enough from the 4 other
/// methods.
typedef AstrometryNet Astro;

#endif /* HOKU_ASTROMETRY_NET_H */